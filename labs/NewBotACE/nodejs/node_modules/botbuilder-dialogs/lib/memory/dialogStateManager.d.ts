/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { DialogContext } from '../dialogContext';
import { MemoryScope } from './scopes';
import { PathResolver } from './pathResolvers';
export interface DialogStateManagerConfiguration {
    /**
     * List of path resolvers used to evaluate memory paths.
     */
    readonly pathResolvers: PathResolver[];
    /**
     * List of the supported memory scopes.
     */
    readonly memoryScopes: MemoryScope[];
}
/**
 * The DialogStateManager manages memory scopes and path resolvers.
 *
 * @remarks
 * MemoryScopes are named root level objects, which can exist either in the dialog context or off
 * of turn state. Path resolvers allow for shortcut behavior for mapping things like
 * $foo -> dialog.foo
 */
export declare class DialogStateManager {
    private readonly dialogContext;
    /**
     * Initializes a new instance of the [DialogStateManager](xref:botbuilder-dialogs.DialogStateManager) class.
     *
     * @param dc The dialog context for the current turn of the conversation.
     * @param configuration Configuration for the dialog state manager.
     */
    constructor(dc: DialogContext, configuration?: DialogStateManagerConfiguration);
    /**
     * Gets or sets the configured path resolvers and memory scopes for the dialog state manager.
     *
     * @remarks
     * There is a single set of configuration information for a given chain of dialog contexts.
     * Assigning a new configuration to any DialogStateManager within the chain will update the
     * configuration for the entire chain.
     */
    configuration: DialogStateManagerConfiguration;
    /**
     * Get the value from memory using path expression.
     *
     * @remarks
     * This always returns a CLONE of the memory, any modifications to the result will not affect memory.
     * @template T The value type to return.
     * @param pathExpression Path expression to use.
     * @param defaultValue (Optional) default value to use if the path isn't found. May be a function that returns the default value to use.
     * @returns The found value or undefined if not found and no `defaultValue` specified.
     */
    getValue<T = any>(pathExpression: string, defaultValue?: T | (() => T)): T;
    /**
     * Set memory to value.
     *
     * @param pathExpression Path to memory.
     * @param value Value to set.
     */
    setValue(pathExpression: string, value: any): void;
    /**
     * Delete property from memory
     *
     * @param pathExpression The leaf property to remove.
     */
    deleteValue(pathExpression: string): void;
    /**
     * Ensures that all memory scopes have been loaded for the current turn.
     *
     * @remarks
     * This should be called at the beginning of the turn.
     */
    loadAllScopes(): Promise<void>;
    /**
     * Saves any changes made to memory scopes.
     *
     * @remarks
     * This should be called at the end of the turn.
     */
    saveAllChanges(): Promise<void>;
    /**
     * Deletes all of the backing memory for a given scope.
     *
     * @param name Name of the scope.
     */
    deleteScopesMemory(name: string): Promise<void>;
    /**
     * Normalizes the path segments of a passed in path.
     *
     * @remarks
     * A path of `profile.address[0]` will be normalized to `profile.address.0`.
     * @param pathExpression The path to normalize.
     * @param allowNestedPaths Optional. If `false` then detection of a nested path will cause an empty path to be returned. Defaults to 'true'.
     * @returns The normalized path.
     */
    parsePath(pathExpression: string, allowNestedPaths?: boolean): (string | number)[];
    /**
     * Transform the path using the registered path transformers.
     *
     * @param pathExpression The path to transform.
     * @returns The transformed path.
     */
    transformPath(pathExpression: string): string;
    /**
     * Gets all memory scopes suitable for logging.
     *
     * @returns Object which represents all memory scopes.
     */
    getMemorySnapshot(): object;
    /**
     * Track when specific paths are changed.
     *
     * @param paths Paths to track.
     * @returns Normalized paths to pass to [anyPathChanged()](#anypathchanged).
     */
    trackPaths(paths: string[]): string[];
    /**
     * Check to see if any path has changed since watermark.
     *
     * @param counter Time counter to compare to.
     * @param paths Paths from [trackPaths()](#trackpaths) to check.
     * @returns True if any path has changed since counter.
     */
    anyPathChanged(counter: number, paths: string[]): boolean;
    /**
     * @private
     * @param path Track path to change.
     */
    private trackChange;
    /**
     * @private
     * @param memory Object memory to resolve.
     * @param segments Segments of the memory to resolve.
     * @param assignment Optional.
     * @returns The value of the memory segment.
     */
    private resolveSegments;
    /**
     * @private
     */
    private findObjectKey;
    /**
     * @private
     * Gets [MemoryScope](xref:botbuilder-dialogs.MemoryScope) by name.
     * @param name Name of scope.
     * @returns The [MemoryScope](xref:botbuilder-dialogs.MemoryScope).
     */
    private getMemoryScope;
    /**
     * Gets the version number.
     *
     * @returns A string with the version number.
     */
    version(): string;
}
//# sourceMappingURL=dialogStateManager.d.ts.map