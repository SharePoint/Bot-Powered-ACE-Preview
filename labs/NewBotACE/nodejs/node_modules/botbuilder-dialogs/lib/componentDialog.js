"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentDialog = void 0;
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const dialogContext_1 = require("./dialogContext");
const dialogContainer_1 = require("./dialogContainer");
const PERSISTED_DIALOG_STATE = 'dialogs';
/**
 * Base class for a dialog that contains other child dialogs.
 *
 * @remarks
 * Component dialogs let you break your bot's logic up into components that can themselves be added
 * as a dialog to another `ComponentDialog` or `DialogSet`. Components can also be exported as part
 * of a node package and used within other bots.
 *
 * To define a new component derive a class from ComponentDialog and add your child dialogs within
 * the classes constructor:
 *
 * ```JavaScript
 * const { ComponentDialog, WaterfallDialog, TextPrompt, NumberPrompt } = require('botbuilder-dialogs');
 *
 * class FillProfileDialog extends ComponentDialog {
 *     constructor(dialogId) {
 *         super(dialogId);
 *
 *         // Add control flow dialogs
 *         this.addDialog(new WaterfallDialog('start', [
 *             async (step) => {
 *                 // Ask user their name
 *                 return await step.prompt('namePrompt', `What's your name?`);
 *             },
 *             async (step) => {
 *                 // Remember the users answer
 *                 step.values['name'] = step.result;
 *
 *                 // Ask user their age.
 *                 return await step.prompt('agePrompt', `Hi ${step.values['name']}. How old are you?`);
 *             },
 *             async (step) => {
 *                 // Remember the users answer
 *                 step.values['age'] = step.result;
 *
 *                 // End the component and return the completed profile.
 *                 return await step.endDialog(step.values);
 *             }
 *         ]));
 *
 *         // Add prompts
 *         this.addDialog(new TextPrompt('namePrompt'));
 *         this.addDialog(new NumberPrompt('agePrompt'))
 *     }
 * }
 * module.exports.FillProfileDialog = FillProfileDialog;
 * ```
 *
 * You can then add new instances of your component to another `DialogSet` or `ComponentDialog`:
 *
 * ```JavaScript
 * const dialogs = new DialogSet(dialogState);
 * dialogs.add(new FillProfileDialog('fillProfile'));
 * ```
 * @param O (Optional) options that can be passed into the `DialogContext.beginDialog()` method.
 */
class ComponentDialog extends dialogContainer_1.DialogContainer {
    /**
     * Called when the dialog is started and pushed onto the parent's dialog stack.
     * By default, this calls the
     * Dialog.BeginDialogAsync(DialogContext, object, CancellationToken) method
     * of the component dialog's initial dialog, as defined by InitialDialogId.
     * Override this method in a derived class to implement interrupt logic.
     *
     * @param outerDC The parent [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options Optional, initial information to pass to the dialog.
     * @returns A Promise representing the asynchronous operation.
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     */
    beginDialog(outerDC, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkForVersionChange(outerDC);
            botbuilder_core_1.telemetryTrackDialogView(this.telemetryClient, this.id);
            // Start the inner dialog.
            const innerDC = this.createChildContext(outerDC);
            const turnResult = yield this.onBeginDialog(innerDC, options);
            // Check for end of inner dialog
            if (turnResult.status !== dialog_1.DialogTurnStatus.waiting) {
                if (turnResult.status === dialog_1.DialogTurnStatus.cancelled) {
                    yield this.endComponent(outerDC, turnResult.result);
                    const cancelledTurnResult = {
                        status: dialog_1.DialogTurnStatus.cancelled,
                        result: turnResult.result,
                    };
                    return cancelledTurnResult;
                }
                // Return result to calling dialog
                return yield this.endComponent(outerDC, turnResult.result);
            }
            // Just signal end of turn
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    /**
     * Called when the dialog is _continued_, where it is the active dialog and the
     * user replies with a new [Activity](xref:botframework-schema.Activity).
     * If this method is *not* overridden, the dialog automatically ends when the user replies.
     *
     * @param outerDC The parent [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @returns A Promise representing the asynchronous operation.
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog. The result may also contain a
     * return value.
     */
    continueDialog(outerDC) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkForVersionChange(outerDC);
            // Continue execution of inner dialog.
            const innerDC = this.createChildContext(outerDC);
            const turnResult = yield this.onContinueDialog(innerDC);
            // Check for end of inner dialog
            if (turnResult.status !== dialog_1.DialogTurnStatus.waiting) {
                // Return result to calling dialog
                return yield this.endComponent(outerDC, turnResult.result);
            }
            // Just signal end of turn
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    /**
     * Called when a child dialog on the parent's dialog stack completed this turn, returning
     * control to this dialog component.
     *
     * @param outerDC The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param _reason Reason why the dialog resumed.
     * @param _result Optional, value returned from the dialog that was called. The type
     * of the value returned is dependent on the child dialog.
     * @returns A Promise representing the asynchronous operation.
     * @remarks
     * If the task is successful, the result indicates whether this dialog is still
     * active after this dialog turn has been processed.
     * Generally, the child dialog was started with a call to
     * beginDialog(DialogContext, object) in the parent's
     * context. However, if the DialogContext.replaceDialog(string, object) method
     * is called, the logical child dialog may be different than the original.
     * If this method is *not* overridden, the dialog automatically calls its
     * RepromptDialog(ITurnContext, DialogInstance) when the user replies.
     */
    resumeDialog(outerDC, _reason, _result) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkForVersionChange(outerDC);
            // Containers are typically leaf nodes on the stack but the dev is free to push other dialogs
            // on top of the stack which will result in the container receiving an unexpected call to
            // resumeDialog() when the pushed on dialog ends.
            // To avoid the container prematurely ending we need to implement this method and simply
            // ask our inner dialog stack to re-prompt.
            yield this.repromptDialog(outerDC.context, outerDC.activeDialog);
            return dialog_1.Dialog.EndOfTurn;
        });
    }
    /**
     * Called when the dialog should re-prompt the user for input.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) object for this turn.
     * @param instance State information for this dialog.
     * @returns A Promise representing the asynchronous operation.
     */
    repromptDialog(context, instance) {
        return __awaiter(this, void 0, void 0, function* () {
            // Forward to inner dialogs
            const innerDC = this.createInnerDC(context, instance);
            yield innerDC.repromptDialog();
            // Notify component.
            yield this.onRepromptDialog(context, instance);
        });
    }
    /**
     * Called when the [Dialog](xref:botbuilder-dialogs.Dialog) is ending.
     *
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) object for this turn.
     * @param instance State information associated with the instance of this component
     * [Dialog](xref:botbuilder-dialogs.Dialog) on its parent's dialog stack.
     * @param reason Reason why the [Dialog](xref:botbuilder-dialogs.Dialog) ended.
     * @returns A Promise representing the asynchronous operation.
     * @remarks When this method is called from the parent dialog's context, the component [Dialog](xref:botbuilder-dialogs.Dialog)
     * cancels all of the dialogs on its inner dialog stack before ending.
     */
    endDialog(context, instance, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            // Forward cancel to inner dialogs
            if (reason === dialog_1.DialogReason.cancelCalled) {
                const innerDC = this.createInnerDC(context, instance);
                yield innerDC.cancelAllDialogs();
            }
            // Notify component
            yield this.onEndDialog(context, instance, reason);
        });
    }
    /**
     * Adds a child [Dialog](xref:botbuilder-dialogs.Dialog) or prompt to the components internal [DialogSet](xref:botbuilder-dialogs.DialogSet).
     *
     * @param dialog The child [Dialog](xref:botbuilder-dialogs.Dialog) or prompt to add.
     * @returns The [ComponentDialog](xref:botbuilder-dialogs.ComponentDialog) after the operation is complete.
     * @remarks
     * The [Dialog.id](xref:botbuilder-dialogs.Dialog.id) of the first child added to the component will be assigned to the initialDialogId property.
     */
    addDialog(dialog) {
        this.dialogs.add(dialog);
        if (this.initialDialogId === undefined) {
            this.initialDialogId = dialog.id;
        }
        return this;
    }
    /**
     * Creates the inner dialog context
     *
     * @param outerDC the outer dialog context
     * @returns The created Dialog Context.
     */
    createChildContext(outerDC) {
        return this.createInnerDC(outerDC, outerDC.activeDialog);
    }
    /**
     * Called anytime an instance of the component has been started.
     *
     * @remarks
     * SHOULD be overridden by components that wish to perform custom interruption logic. The
     * default implementation calls `innerDC.beginDialog()` with the dialog assigned to
     * [initialDialogId](#initialdialogid).
     * @param innerDC Dialog context for the components internal `DialogSet`.
     * @param options (Optional) options that were passed to the component by its parent.
     * @returns {Promise<DialogTurnResult>} A promise resolving to the dialog turn result.
     */
    onBeginDialog(innerDC, options) {
        return innerDC.beginDialog(this.initialDialogId, options);
    }
    /**
     * Called anytime a multi-turn component receives additional activities.
     *
     * @remarks
     * SHOULD be overridden by components that wish to perform custom interruption logic. The
     * default implementation calls `innerDC.continueDialog()`.
     * @param innerDC Dialog context for the components internal `DialogSet`.
     * @returns {Promise<DialogTurnResult>} A promise resolving to the dialog turn result.
     */
    onContinueDialog(innerDC) {
        return innerDC.continueDialog();
    }
    /**
     * Called when the component is ending.
     *
     * @remarks
     * If the `reason` code is equal to `DialogReason.cancelCalled`, then any active child dialogs
     * will be cancelled before this method is called.
     * @param _context Context for the current turn of conversation.
     * @param _instance The components instance data within its parents dialog stack.
     * @param _reason The reason the component is ending.
     * @returns A promise representing the asynchronous operation.
     */
    onEndDialog(_context, _instance, _reason) {
        return Promise.resolve();
    }
    /**
     * Called when the component has been requested to re-prompt the user for input.
     *
     * @remarks
     * The active child dialog will have already been asked to reprompt before this method is called.
     * @param _context Context for the current turn of conversation.
     * @param _instance The instance of the current dialog.
     * @returns A promise representing the asynchronous operation.
     */
    onRepromptDialog(_context, _instance) {
        return Promise.resolve();
    }
    /**
     * Called when the components last active child dialog ends and the component is ending.
     *
     * @remarks
     * SHOULD be overridden by components that wish to perform custom logic before the component
     * ends.  The default implementation calls `outerDC.endDialog()` with the `result` returned
     * from the last active child dialog.
     * @param outerDC Dialog context for the parents `DialogSet`.
     * @param result Result returned by the last active child dialog. Can be a value of `undefined`.
     * @returns {Promise<DialogTurnResult>} A promise resolving to the dialog turn result.
     */
    endComponent(outerDC, result) {
        return outerDC.endDialog(result);
    }
    /**
     * @private
     * @param context [TurnContext](xref:botbuilder-core.TurnContext) or [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation with the user.
     * @param instance [DialogInstance](xref:botbuilder-dialogs.DialogInstance) which contains the current state information for this dialog.
     * @returns A new [DialogContext](xref:botbuilder-dialogs.DialogContext) instance.
     * @remarks
     * You should only call this if you don't have a dc to work with (such as OnResume())
     */
    createInnerDC(context, instance) {
        if (!instance) {
            const dialogInstance = { state: {} };
            instance = dialogInstance;
        }
        const dialogState = instance.state[PERSISTED_DIALOG_STATE] || { dialogStack: [] };
        instance.state[PERSISTED_DIALOG_STATE] = dialogState;
        return new dialogContext_1.DialogContext(this.dialogs, context, dialogState);
    }
}
exports.ComponentDialog = ComponentDialog;
//# sourceMappingURL=componentDialog.js.map