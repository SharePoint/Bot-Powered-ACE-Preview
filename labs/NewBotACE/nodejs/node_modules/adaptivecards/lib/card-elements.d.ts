import * as Enums from "./enums";
import * as Shared from "./shared";
import * as HostConfig from "./host-config";
export declare function createActionInstance(parent: CardElement, json: any, forbiddenActionTypes: string[], allowFallback: boolean, errors: Array<HostConfig.IValidationError>): Action;
export declare function createElementInstance(parent: CardElement, json: any, allowFallback: boolean, errors: Array<HostConfig.IValidationError>): CardElement;
export declare abstract class SerializableObject {
    private _rawProperties;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    setCustomProperty(name: string, value: any): void;
    getCustomProperty(name: string): any;
}
export declare class ValidationFailure {
    readonly cardObject: CardObject;
    readonly errors: HostConfig.IValidationError[];
    constructor(cardObject: CardObject);
}
export declare class ValidationResults {
    private getFailureIndex;
    readonly allIds: Shared.Dictionary<number>;
    readonly failures: ValidationFailure[];
    addFailure(cardObject: CardObject, error: HostConfig.IValidationError): void;
}
export declare abstract class CardObject extends SerializableObject {
    abstract getJsonTypeName(): string;
    abstract shouldFallback(): boolean;
    abstract setParent(parent: CardElement): any;
    id: string;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    validateProperties(): ValidationResults;
}
export declare type CardElementHeight = "auto" | "stretch";
export declare abstract class CardElement extends CardObject {
    private _shouldFallback;
    private _lang;
    private _hostConfig?;
    private _parent;
    private _renderedElement;
    private _separatorElement;
    private _isVisible;
    private _truncatedDueToOverflow;
    private _defaultRenderedElementDisplayMode;
    private _padding;
    private internalRenderSeparator;
    private updateRenderedElementVisibility;
    private hideElementDueToOverflow;
    private showElementHiddenDueToOverflow;
    private handleOverflow;
    private resetOverflow;
    protected createPlaceholderElement(): HTMLElement;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected abstract internalRender(): HTMLElement;
    protected overrideInternalRender(): HTMLElement;
    protected applyPadding(): void;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected getDefaultPadding(): Shared.PaddingDefinition;
    protected getHasBackground(): boolean;
    protected getPadding(): Shared.PaddingDefinition;
    protected setPadding(value: Shared.PaddingDefinition): void;
    protected readonly supportsMinHeight: boolean;
    protected readonly useDefaultSizing: boolean;
    protected readonly allowCustomPadding: boolean;
    protected readonly separatorOrientation: Enums.Orientation;
    protected readonly defaultStyle: string;
    readonly requires: HostConfig.HostCapabilities;
    horizontalAlignment?: Enums.HorizontalAlignment;
    spacing: Enums.Spacing;
    separator: boolean;
    customCssSelector: string;
    height: CardElementHeight;
    minPixelHeight?: number;
    abstract getJsonTypeName(): string;
    asString(): string;
    isBleeding(): boolean;
    toJSON(): any;
    setParent(value: CardElement): void;
    getEffectiveStyle(): string;
    getForbiddenElementTypes(): Array<string>;
    getForbiddenActionTypes(): Array<any>;
    getImmediateSurroundingPadding(result: Shared.PaddingDefinition, processTop?: boolean, processRight?: boolean, processBottom?: boolean, processLeft?: boolean): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getActionCount(): number;
    getActionAt(index: number): Action;
    remove(): boolean;
    render(): HTMLElement;
    updateLayout(processChildren?: boolean): void;
    indexOf(cardElement: CardElement): number;
    isDesignMode(): boolean;
    isRendered(): boolean;
    isFirstElement(element: CardElement): boolean;
    isLastElement(element: CardElement): boolean;
    isAtTheVeryLeft(): boolean;
    isAtTheVeryRight(): boolean;
    isAtTheVeryTop(): boolean;
    isAtTheVeryBottom(): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    isLeftMostElement(element: CardElement): boolean;
    isRightMostElement(element: CardElement): boolean;
    isTopElement(element: CardElement): boolean;
    isBottomElement(element: CardElement): boolean;
    isHiddenDueToOverflow(): boolean;
    getRootElement(): CardElement;
    getParentContainer(): Container;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    getElementById(id: string): CardElement;
    getActionById(id: string): Action;
    shouldFallback(): boolean;
    setShouldFallback(value: boolean): void;
    getEffectivePadding(): Shared.PaddingDefinition;
    lang: string;
    hostConfig: HostConfig.HostConfig;
    readonly index: number;
    readonly isInteractive: boolean;
    readonly isStandalone: boolean;
    readonly isInline: boolean;
    readonly parent: CardElement;
    isVisible: boolean;
    readonly hasVisibleSeparator: boolean;
    readonly renderedElement: HTMLElement;
    readonly separatorElement: HTMLElement;
}
export declare abstract class BaseTextBlock extends CardElement {
    private _text;
    private _selectAction;
    protected getEffectiveStyleDefinition(): HostConfig.ContainerStyleDefinition;
    protected getFontSize(fontType: HostConfig.FontTypeDefinition): number;
    protected getColorDefinition(colorSet: HostConfig.ColorSetDefinition, color: Enums.TextColor): HostConfig.TextColorDefinition;
    protected setText(value: string): void;
    size: Enums.TextSize;
    weight: Enums.TextWeight;
    color: Enums.TextColor;
    isSubtle: boolean;
    fontType?: Enums.FontType;
    asString(): string;
    toJSON(): any;
    applyStylesTo(targetElement: HTMLElement): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly effectiveColor: Enums.TextColor;
    text: string;
    selectAction: Action;
}
export declare class TextBlock extends BaseTextBlock {
    private _computedLineHeight;
    private _originalInnerHtml;
    private _processedText;
    private _treatAsPlainText;
    private restoreOriginalContent;
    private truncateIfSupported;
    protected setText(value: string): void;
    protected getRenderedDomElementType(): string;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    wrap: boolean;
    maxLines: number;
    useMarkdown: boolean;
    toJSON(): any;
    applyStylesTo(targetElement: HTMLElement): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getJsonTypeName(): string;
    updateLayout(processChildren?: boolean): void;
}
export declare class TextRun extends BaseTextBlock {
    protected internalRender(): HTMLElement;
    italic: boolean;
    strikethrough: boolean;
    highlight: boolean;
    applyStylesTo(targetElement: HTMLElement): void;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getJsonTypeName(): string;
    readonly isStandalone: boolean;
    readonly isInline: boolean;
}
export declare class RichTextBlock extends CardElement {
    private _inlines;
    private internalAddInline;
    protected internalRender(): HTMLElement;
    asString(): string;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    getJsonTypeName(): string;
    getInlineCount(): number;
    getInlineAt(index: number): CardElement;
    addInline(inline: CardElement): void;
    removeInline(inline: CardElement): boolean;
}
export declare class Fact extends SerializableObject {
    name: string;
    value: string;
    constructor(name?: string, value?: string);
    parse(json: any): void;
    toJSON(): any;
}
export declare class FactSet extends CardElement {
    protected readonly useDefaultSizing: boolean;
    protected internalRender(): HTMLElement;
    facts: Array<Fact>;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
}
export declare class Image extends CardElement {
    private _selectAction;
    private parseDimension;
    private applySize;
    protected readonly useDefaultSizing: boolean;
    protected internalRender(): HTMLElement;
    style: Enums.ImageStyle;
    backgroundColor: string;
    url: string;
    size: Enums.Size;
    width: Shared.SizeAndUnit;
    pixelWidth?: number;
    pixelHeight?: number;
    altText: string;
    toJSON(): any;
    getJsonTypeName(): string;
    getActionById(id: string): Action;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    selectAction: Action;
}
export declare abstract class CardElementContainer extends CardElement {
    private _selectAction;
    protected isElementAllowed(element: CardElement, forbiddenElementTypes: Array<string>): boolean;
    protected applyPadding(): void;
    protected getSelectAction(): Action;
    protected setSelectAction(value: Action): void;
    protected readonly isSelectable: boolean;
    abstract getItemCount(): number;
    abstract getItemAt(index: number): CardElement;
    abstract getFirstVisibleRenderedItem(): CardElement;
    abstract getLastVisibleRenderedItem(): CardElement;
    abstract removeItem(item: CardElement): boolean;
    allowVerticalOverflow: boolean;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    render(): HTMLElement;
    updateLayout(processChildren?: boolean): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    getElementById(id: string): CardElement;
}
export declare class ImageSet extends CardElementContainer {
    private _images;
    protected internalRender(): HTMLElement;
    imageSize: Enums.Size;
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getFirstVisibleRenderedItem(): CardElement;
    getLastVisibleRenderedItem(): CardElement;
    removeItem(item: CardElement): boolean;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    addImage(image: Image): void;
    indexOf(cardElement: CardElement): number;
}
export declare class MediaSource extends SerializableObject {
    mimeType: string;
    url: string;
    constructor(url?: string, mimeType?: string);
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
}
export declare class Media extends CardElement {
    static readonly supportedMediaTypes: string[];
    private _selectedMediaType;
    private _selectedSources;
    private getPosterUrl;
    private processSources;
    private renderPoster;
    private renderMediaPlayer;
    protected internalRender(): HTMLElement;
    static onPlay: (sender: Media) => void;
    sources: Array<MediaSource>;
    poster: string;
    altText: string;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    getJsonTypeName(): string;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    readonly selectedMediaType: string;
}
export declare class InputValidationOptions extends SerializableObject {
    necessity: Enums.InputValidationNecessity;
    errorMessage: string;
    parse(json: any): void;
    toJSON(): any;
}
export declare abstract class Input extends CardElement implements Shared.IInput {
    private _outerContainerElement;
    private _inputControlContainerElement;
    private _errorMessageElement;
    private _renderedInputControlElement;
    private _defaultValue;
    protected readonly isNullable: boolean;
    protected readonly renderedInputControlElement: HTMLElement;
    protected readonly inputControlContainerElement: HTMLElement;
    protected overrideInternalRender(): HTMLElement;
    protected valueChanged(): void;
    protected resetValidationFailureCue(): void;
    protected showValidationErrorMessage(): void;
    protected parseInputValue(value: string): string;
    abstract readonly value: string;
    onValueChanged: (sender: Input) => void;
    readonly validation: InputValidationOptions;
    title: string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    validateValue(): boolean;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getAllInputs(): Array<Input>;
    defaultValue: string;
    readonly isInteractive: boolean;
}
export declare class TextInput extends Input {
    private _inlineAction;
    protected internalRender(): HTMLElement;
    protected overrideInternalRender(): HTMLElement;
    maxLength: number;
    isMultiline: boolean;
    placeholder: string;
    style: Enums.InputTextStyle;
    getJsonTypeName(): string;
    getActionById(id: string): Action;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    inlineAction: Action;
    readonly value: string;
}
export declare class ToggleInput extends Input {
    private _checkboxInputElement;
    protected internalRender(): HTMLElement;
    protected readonly isNullable: boolean;
    valueOn: string;
    valueOff: string;
    wrap: boolean;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class Choice extends SerializableObject {
    title: string;
    value: string;
    constructor(title?: string, value?: string);
    parse(json: any): void;
    toJSON(): any;
}
export declare class ChoiceSetInput extends Input {
    private static uniqueCategoryCounter;
    private static getUniqueCategoryName;
    private _selectElement;
    private _toggleInputs;
    protected internalApplyAriaCurrent(): void;
    protected internalRender(): HTMLElement;
    choices: Array<Choice>;
    isCompact: boolean;
    isMultiSelect: boolean;
    placeholder: string;
    wrap: boolean;
    getJsonTypeName(): string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly value: string;
}
export declare class NumberInput extends Input {
    private _numberInputElement;
    private _min;
    private _max;
    protected internalRender(): HTMLElement;
    placeholder: string;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    min: number;
    max: number;
    readonly value: string;
    readonly valueAsNumber: number;
}
export declare class DateInput extends Input {
    private _dateInputElement;
    private _min;
    private _max;
    protected internalRender(): HTMLElement;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    min: string;
    max: string;
    readonly value: string;
}
export declare class TimeInput extends Input {
    private _timeInputElement;
    private _min;
    private _max;
    protected internalRender(): HTMLElement;
    protected parseInputValue(value: string): string;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    min: string;
    max: string;
    readonly value: string;
}
export declare abstract class Action extends CardObject {
    private _shouldFallback;
    private _parent;
    private _actionCollection;
    private _renderedElement;
    private setCollection;
    protected addCssClasses(element: HTMLElement): void;
    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
    protected internalValidateInputs(referencedInputs: Shared.Dictionary<Input>): Array<Input>;
    abstract getJsonTypeName(): string;
    readonly requires: HostConfig.HostCapabilities;
    title: string;
    iconUrl: string;
    style: string;
    onExecute: (sender: Action) => void;
    getAriaRole(): string;
    getHref(): string;
    toJSON(): any;
    render(baseCssClass?: string): void;
    setParent(value: CardElement): void;
    execute(): void;
    prepareForExecution(): boolean;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    remove(): boolean;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    getActionById(id: string): Action;
    getReferencedInputs(): Shared.Dictionary<Input>;
    validateInputs(): Input[];
    shouldFallback(): boolean;
    isPrimary: boolean;
    readonly ignoreInputValidation: boolean;
    readonly parent: CardElement;
    readonly renderedElement: HTMLElement;
}
export declare class SubmitAction extends Action {
    static readonly JsonTypeName: "Action.Submit";
    private _isPrepared;
    private _originalData;
    private _processedData;
    private _ignoreInputValidation;
    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    ignoreInputValidation: boolean;
    data: Object;
}
export declare class OpenUrlAction extends Action {
    static readonly JsonTypeName: "Action.OpenUrl";
    url: string;
    getJsonTypeName(): string;
    getAriaRole(): string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    getHref(): string;
}
export declare class ToggleVisibilityAction extends Action {
    static readonly JsonTypeName: "Action.ToggleVisibility";
    targetElements: {};
    getJsonTypeName(): string;
    execute(): void;
    parse(json: any): void;
    toJSON(): any;
    addTargetElement(elementId: string, isVisible?: boolean): void;
    removeTargetElement(elementId: any): void;
}
export declare class HttpHeader extends SerializableObject {
    private _value;
    name: string;
    constructor(name?: string, value?: string);
    parse(json: any): void;
    toJSON(): any;
    getReferencedInputs(inputs: Array<Input>, referencedInputs: Shared.Dictionary<Input>): void;
    prepareForExecution(inputs: Shared.Dictionary<Input>): void;
    value: string;
}
export declare class HttpAction extends Action {
    static readonly JsonTypeName: "Action.Http";
    private _url;
    private _body;
    private _headers;
    private _ignoreInputValidation;
    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
    method: string;
    getJsonTypeName(): string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    ignoreInputValidation: boolean;
    url: string;
    body: string;
    headers: Array<HttpHeader>;
}
export declare class ShowCardAction extends Action {
    static readonly JsonTypeName: "Action.ShowCard";
    protected addCssClasses(element: HTMLElement): void;
    readonly card: AdaptiveCard;
    getJsonTypeName(): string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    setParent(value: CardElement): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    getActionById(id: string): Action;
}
export declare class ActionSet extends CardElement {
    private _actionCollection;
    protected internalRender(): HTMLElement;
    orientation?: Enums.Orientation;
    constructor();
    toJSON(): any;
    isBleedingAtBottom(): boolean;
    getJsonTypeName(): string;
    getActionCount(): number;
    getActionAt(index: number): Action;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    addAction(action: Action): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    readonly isInteractive: boolean;
}
export declare abstract class StylableCardElementContainer extends CardElementContainer {
    private _style?;
    private _bleed;
    protected applyBackground(): void;
    protected applyPadding(): void;
    protected getHasBackground(): boolean;
    protected getDefaultPadding(): Shared.PaddingDefinition;
    protected getHasExpandedAction(): boolean;
    protected getBleed(): boolean;
    protected setBleed(value: boolean): void;
    protected readonly renderedActionCount: number;
    protected readonly hasExplicitStyle: boolean;
    protected readonly allowCustomStyle: boolean;
    protected readonly supportsMinHeight: boolean;
    isBleeding(): boolean;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    render(): HTMLElement;
    getEffectiveStyle(): string;
    style: string;
}
export declare class BackgroundImage extends SerializableObject {
    private static readonly defaultFillMode;
    private static readonly defaultHorizontalAlignment;
    private static readonly defaultVerticalAlignment;
    url: string;
    fillMode: Enums.FillMode;
    horizontalAlignment: Enums.HorizontalAlignment;
    verticalAlignment: Enums.VerticalAlignment;
    reset(): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    toJSON(): any;
    apply(element: HTMLElement): void;
    isValid(): boolean;
}
export declare class Container extends StylableCardElementContainer {
    private _items;
    private _renderedItems;
    private insertItemAt;
    protected supportsExcplitiHeight(): boolean;
    protected getItemsCollectionPropertyName(): string;
    protected applyBackground(): void;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected getHasBackground(): boolean;
    protected readonly isSelectable: boolean;
    readonly backgroundImage: BackgroundImage;
    verticalContentAlignment: Enums.VerticalAlignment;
    rtl?: boolean;
    toJSON(): any;
    getItemCount(): number;
    getItemAt(index: number): CardElement;
    getFirstVisibleRenderedItem(): CardElement;
    getLastVisibleRenderedItem(): CardElement;
    getJsonTypeName(): string;
    isFirstElement(element: CardElement): boolean;
    isLastElement(element: CardElement): boolean;
    isRtl(): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    indexOf(cardElement: CardElement): number;
    addItem(item: CardElement): void;
    insertItemBefore(item: CardElement, insertBefore: CardElement): void;
    insertItemAfter(item: CardElement, insertAfter: CardElement): void;
    removeItem(item: CardElement): boolean;
    clear(): void;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    getActionById(id: string): Action;
    padding: Shared.PaddingDefinition;
    selectAction: Action;
    bleed: boolean;
}
export declare type ColumnWidth = Shared.SizeAndUnit | "auto" | "stretch";
export declare class Column extends Container {
    private _computedWeight;
    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
    protected readonly separatorOrientation: Enums.Orientation;
    width: ColumnWidth;
    constructor(width?: ColumnWidth);
    getJsonTypeName(): string;
    toJSON(): any;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    readonly hasVisibleSeparator: boolean;
    readonly isStandalone: boolean;
}
export declare class ColumnSet extends StylableCardElementContainer {
    private _columns;
    private _renderedColumns;
    private createColumnInstance;
    protected internalRender(): HTMLElement;
    protected truncateOverflow(maxHeight: number): boolean;
    protected undoOverflowTruncation(): void;
    protected readonly isSelectable: boolean;
    toJSON(): any;
    isFirstElement(element: CardElement): boolean;
    isBleedingAtTop(): boolean;
    isBleedingAtBottom(): boolean;
    getCount(): number;
    getItemCount(): number;
    getFirstVisibleRenderedItem(): CardElement;
    getLastVisibleRenderedItem(): CardElement;
    getColumnAt(index: number): Column;
    getItemAt(index: number): CardElement;
    getJsonTypeName(): string;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    internalValidateProperties(context: ValidationResults): void;
    addColumn(column: Column): void;
    removeItem(item: CardElement): boolean;
    indexOf(cardElement: CardElement): number;
    isLeftMostElement(element: CardElement): boolean;
    isRightMostElement(element: CardElement): boolean;
    isTopElement(element: CardElement): boolean;
    isBottomElement(element: CardElement): boolean;
    getActionById(id: string): Action;
    bleed: boolean;
    padding: Shared.PaddingDefinition;
    selectAction: Action;
}
export interface ITypeRegistration<T> {
    typeName: string;
    createInstance: () => T;
}
export declare abstract class ContainerWithActions extends Container {
    private _actionCollection;
    protected internalRender(): HTMLElement;
    protected getHasExpandedAction(): boolean;
    protected readonly renderedActionCount: number;
    protected readonly renderIfEmpty: boolean;
    constructor();
    toJSON(): any;
    getActionCount(): number;
    getActionAt(index: number): Action;
    getActionById(id: string): Action;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    internalValidateProperties(context: ValidationResults): void;
    isLastElement(element: CardElement): boolean;
    addAction(action: Action): void;
    clear(): void;
    getAllInputs(): Array<Input>;
    getResourceInformation(): Array<Shared.IResourceInformation>;
    isBleedingAtBottom(): boolean;
    readonly isStandalone: boolean;
}
export declare abstract class TypeRegistry<T> {
    private _items;
    private findTypeRegistration;
    constructor();
    clear(): void;
    abstract reset(): any;
    registerType(typeName: string, createInstance: () => T): void;
    unregisterType(typeName: string): void;
    createInstance(typeName: string): T;
    getItemCount(): number;
    getItemAt(index: number): ITypeRegistration<T>;
}
export declare class ElementTypeRegistry extends TypeRegistry<CardElement> {
    reset(): void;
}
export declare class ActionTypeRegistry extends TypeRegistry<Action> {
    reset(): void;
}
export interface IMarkdownProcessingResult {
    didProcess: boolean;
    outputHtml?: any;
}
export declare class AdaptiveCard extends ContainerWithActions {
    private static currentVersion;
    static useAdvancedTextBlockTruncation: boolean;
    static useAdvancedCardBottomTruncation: boolean;
    static useMarkdownInRadioButtonAndCheckbox: boolean;
    static allowMarkForTextHighlighting: boolean;
    static alwaysBleedSeparators: boolean;
    static enableFullJsonRoundTrip: boolean;
    static useBuiltInInputValidation: boolean;
    static displayInputValidationErrors: boolean;
    static readonly elementTypeRegistry: ElementTypeRegistry;
    static readonly actionTypeRegistry: ActionTypeRegistry;
    static onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
    static onExecuteAction: (action: Action) => void;
    static onElementVisibilityChanged: (element: CardElement) => void;
    static onImageLoaded: (image: Image) => void;
    static onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
    static onInputValueChanged: (input: Input) => void;
    static onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    static onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    static onParseError: (error: HostConfig.IValidationError) => void;
    static onProcessMarkdown: (text: string, result: IMarkdownProcessingResult) => void;
    static processMarkdown: (text: string) => string;
    static applyMarkdown(text: string): IMarkdownProcessingResult;
    private _cardTypeName?;
    private _fallbackCard;
    private isVersionSupported;
    protected getItemsCollectionPropertyName(): string;
    protected internalRender(): HTMLElement;
    protected getHasBackground(): boolean;
    protected getDefaultPadding(): Shared.PaddingDefinition;
    protected readonly renderIfEmpty: boolean;
    protected readonly bypassVersionCheck: boolean;
    protected readonly allowCustomStyle: boolean;
    protected readonly hasBackground: boolean;
    onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
    onExecuteAction: (action: Action) => void;
    onElementVisibilityChanged: (element: CardElement) => void;
    onImageLoaded: (image: Image) => void;
    onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
    onInputValueChanged: (input: Input) => void;
    onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
    version?: HostConfig.Version;
    fallbackText: string;
    speak: string;
    designMode: boolean;
    getJsonTypeName(): string;
    toJSON(): any;
    internalValidateProperties(context: ValidationResults): void;
    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
    render(target?: HTMLElement): HTMLElement;
    updateLayout(processChildren?: boolean): void;
    shouldFallback(): boolean;
    readonly hasVisibleSeparator: boolean;
}
