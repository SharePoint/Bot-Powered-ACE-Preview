declare module 'adaptivecards/enums' {
	export class ActionStyle {
	    static readonly Default: "default";
	    static readonly Positive: "positive";
	    static readonly Destructive: "destructive";
	}
	export enum Size {
	    Auto = 0,
	    Stretch = 1,
	    Small = 2,
	    Medium = 3,
	    Large = 4
	}
	export enum SizeUnit {
	    Weight = 0,
	    Pixel = 1
	}
	export enum TextSize {
	    Small = 0,
	    Default = 1,
	    Medium = 2,
	    Large = 3,
	    ExtraLarge = 4
	}
	export enum TextWeight {
	    Lighter = 0,
	    Default = 1,
	    Bolder = 2
	}
	export enum FontType {
	    Default = 0,
	    Monospace = 1
	}
	export enum Spacing {
	    None = 0,
	    Small = 1,
	    Default = 2,
	    Medium = 3,
	    Large = 4,
	    ExtraLarge = 5,
	    Padding = 6
	}
	export enum TextColor {
	    Default = 0,
	    Dark = 1,
	    Light = 2,
	    Accent = 3,
	    Good = 4,
	    Warning = 5,
	    Attention = 6
	}
	export enum HorizontalAlignment {
	    Left = 0,
	    Center = 1,
	    Right = 2
	}
	export enum VerticalAlignment {
	    Top = 0,
	    Center = 1,
	    Bottom = 2
	}
	export enum ActionAlignment {
	    Left = 0,
	    Center = 1,
	    Right = 2,
	    Stretch = 3
	}
	export enum ImageStyle {
	    Default = 0,
	    Person = 1
	}
	export enum ShowCardActionMode {
	    Inline = 0,
	    Popup = 1
	}
	export enum Orientation {
	    Horizontal = 0,
	    Vertical = 1
	}
	export enum FillMode {
	    Cover = 0,
	    RepeatHorizontally = 1,
	    RepeatVertically = 2,
	    Repeat = 3
	}
	export enum ActionIconPlacement {
	    LeftOfTitle = 0,
	    AboveTitle = 1
	}
	export enum InputTextStyle {
	    Text = 0,
	    Tel = 1,
	    Url = 2,
	    Email = 3
	}
	export enum InputValidationNecessity {
	    Optional = 0,
	    Required = 1,
	    RequiredWithVisualCue = 2
	}
	export class ContainerStyle {
	    static readonly Default: "default";
	    static readonly Emphasis: "emphasis";
	    static readonly Accent: "accent";
	    static readonly Good: "good";
	    static readonly Attention: "attention";
	    static readonly Warning: "warning";
	}
	export enum ValidationError {
	    Hint = 0,
	    ActionTypeNotAllowed = 1,
	    CollectionCantBeEmpty = 2,
	    Deprecated = 3,
	    ElementTypeNotAllowed = 4,
	    InteractivityNotAllowed = 5,
	    InvalidPropertyValue = 6,
	    MissingCardType = 7,
	    PropertyCantBeNull = 8,
	    TooManyActions = 9,
	    UnknownActionType = 10,
	    UnknownElementType = 11,
	    UnsupportedCardVersion = 12,
	    DuplicateId = 13
	}
	export enum ContainerFitStatus {
	    FullyInContainer = 0,
	    Overflowing = 1,
	    FullyOutOfContainer = 2
	}

}
declare module 'adaptivecards/shared' {
	import * as Enums from 'adaptivecards/enums';
	export class GlobalSettings {
	    static setTabIndexAtCardRoot: boolean;
	}
	export const ContentTypes: {
	    applicationJson: string;
	    applicationXWwwFormUrlencoded: string;
	};
	export interface ISeparationDefinition {
	    spacing: number;
	    lineThickness?: number;
	    lineColor?: string;
	}
	export interface IInput {
	    id: string;
	    value: string;
	    validateValue(): boolean;
	}
	export type Dictionary<T> = {
	    [key: string]: T;
	};
	export class StringWithSubstitutions {
	    private _isProcessed;
	    private _original;
	    private _processed;
	    getReferencedInputs(inputs: IInput[], referencedInputs: Dictionary<IInput>): void;
	    substituteInputValues(inputs: Dictionary<IInput>, contentType: string): void;
	    getOriginal(): string;
	    get(): string;
	    set(value: string): void;
	}
	export class SpacingDefinition {
	    left: number;
	    top: number;
	    right: number;
	    bottom: number;
	    constructor(top?: number, right?: number, bottom?: number, left?: number);
	}
	export class PaddingDefinition {
	    top: Enums.Spacing;
	    right: Enums.Spacing;
	    bottom: Enums.Spacing;
	    left: Enums.Spacing;
	    constructor(top?: Enums.Spacing, right?: Enums.Spacing, bottom?: Enums.Spacing, left?: Enums.Spacing);
	}
	export class SizeAndUnit {
	    physicalSize: number;
	    unit: Enums.SizeUnit;
	    static parse(input: any, requireUnitSpecifier?: boolean): SizeAndUnit;
	    constructor(physicalSize: number, unit: Enums.SizeUnit);
	}
	export interface IResourceInformation {
	    url: string;
	    mimeType: string;
	}
	/**
	 * Fast UUID generator, RFC4122 version 4 compliant.
	 * @author Jeff Ward (jcward.com).
	 * @license MIT license
	 * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	 **/
	export class UUID {
	    private static lut;
	    static generate(): string;
	    static initialize(): void;
	}

}
declare module 'adaptivecards/host-config' {
	import * as Enums from 'adaptivecards/enums';
	import * as Shared from 'adaptivecards/shared';
	export interface IValidationError {
	    error: Enums.ValidationError;
	    message: string;
	}
	export class ColorDefinition {
	    default: string;
	    subtle: string;
	    constructor(defaultColor?: string, subtleColor?: string);
	    parse(obj?: any): void;
	}
	export class TextColorDefinition extends ColorDefinition {
	    readonly highlightColors: ColorDefinition;
	    parse(obj?: any): void;
	}
	export class AdaptiveCardConfig {
	    allowCustomStyle: boolean;
	    constructor(obj?: any);
	}
	export class ImageSetConfig {
	    imageSize: Enums.Size;
	    maxImageHeight: number;
	    constructor(obj?: any);
	    toJSON(): {
	        imageSize: string;
	        maxImageHeight: number;
	    };
	}
	export class MediaConfig {
	    defaultPoster: string;
	    allowInlinePlayback: boolean;
	    constructor(obj?: any);
	    toJSON(): {
	        defaultPoster: string;
	        allowInlinePlayback: boolean;
	    };
	}
	export class FactTextDefinition {
	    size: Enums.TextSize;
	    color: Enums.TextColor;
	    isSubtle: boolean;
	    weight: Enums.TextWeight;
	    wrap: boolean;
	    constructor(obj?: any);
	    getDefaultWeight(): Enums.TextWeight;
	    toJSON(): any;
	}
	export class FactTitleDefinition extends FactTextDefinition {
	    maxWidth?: number;
	    weight: Enums.TextWeight;
	    constructor(obj?: any);
	    getDefaultWeight(): Enums.TextWeight;
	}
	export class FactSetConfig {
	    readonly title: FactTitleDefinition;
	    readonly value: FactTextDefinition;
	    spacing: number;
	    constructor(obj?: any);
	}
	export class ShowCardActionConfig {
	    actionMode: Enums.ShowCardActionMode;
	    inlineTopMargin: number;
	    style?: string;
	    constructor(obj?: any);
	    toJSON(): {
	        actionMode: string;
	        inlineTopMargin: number;
	        style: string;
	    };
	}
	export class ActionsConfig {
	    maxActions: number;
	    spacing: Enums.Spacing;
	    buttonSpacing: number;
	    readonly showCard: ShowCardActionConfig;
	    preExpandSingleShowCardAction?: boolean;
	    actionsOrientation: Enums.Orientation;
	    actionAlignment: Enums.ActionAlignment;
	    iconPlacement: Enums.ActionIconPlacement;
	    allowTitleToWrap: boolean;
	    iconSize: number;
	    constructor(obj?: any);
	    toJSON(): {
	        maxActions: number;
	        spacing: string;
	        buttonSpacing: number;
	        showCard: ShowCardActionConfig;
	        preExpandSingleShowCardAction: boolean;
	        actionsOrientation: string;
	        actionAlignment: string;
	    };
	}
	export class ColorSetDefinition {
	    private parseSingleColor;
	    default: TextColorDefinition;
	    dark: TextColorDefinition;
	    light: TextColorDefinition;
	    accent: TextColorDefinition;
	    good: TextColorDefinition;
	    warning: TextColorDefinition;
	    attention: TextColorDefinition;
	    constructor(obj?: any);
	    parse(obj: any): void;
	}
	export class ContainerStyleDefinition {
	    backgroundColor?: string;
	    readonly foregroundColors: ColorSetDefinition;
	    highlightBackgroundColor?: string;
	    highlightForegroundColor?: string;
	    parse(obj: any): void;
	    constructor(obj?: any);
	    readonly isBuiltIn: boolean;
	}
	export interface ILineHeightDefinitions {
	    small: number;
	    medium: number;
	    default: number;
	    large: number;
	    extraLarge: number;
	}
	export class ContainerStyleSet {
	    private _allStyles;
	    constructor(obj?: any);
	    toJSON(): any;
	    getStyleByName(name: string, defaultValue?: ContainerStyleDefinition): ContainerStyleDefinition;
	    readonly default: ContainerStyleDefinition;
	    readonly emphasis: ContainerStyleDefinition;
	}
	export class Version {
	    private _versionString;
	    private _major;
	    private _minor;
	    private _isValid;
	    private _label;
	    constructor(major?: number, minor?: number, label?: string);
	    static parse(versionString: string, errors?: Array<IValidationError>): Version;
	    toString(): string;
	    compareTo(otherVersion: Version): number;
	    readonly label: string;
	    readonly major: number;
	    readonly minor: number;
	    readonly isValid: boolean;
	}
	export type HostCapabilityVersion = Version | "*";
	export type HostCapabilityMap = {
	    [key: string]: HostCapabilityVersion;
	};
	export class HostCapabilities {
	    private setCapability;
	    capabilities: HostCapabilityMap;
	    parse(json: any, errors?: Array<IValidationError>): void;
	    hasCapability(name: string, version: HostCapabilityVersion): boolean;
	    areAllMet(hostCapabilities: HostCapabilities): boolean;
	}
	export interface IFontSizeDefinitions {
	    small: number;
	    default: number;
	    medium: number;
	    large: number;
	    extraLarge: number;
	}
	export interface IFontWeightDefinitions {
	    lighter: number;
	    default: number;
	    bolder: number;
	}
	export class FontTypeDefinition {
	    static readonly monospace: FontTypeDefinition;
	    fontFamily?: string;
	    fontSizes: IFontSizeDefinitions;
	    fontWeights: IFontWeightDefinitions;
	    constructor(fontFamily?: string);
	    parse(obj?: any): void;
	}
	export class FontTypeSet {
	    default: FontTypeDefinition;
	    monospace: FontTypeDefinition;
	    constructor(obj?: any);
	    getStyleDefinition(style: Enums.FontType): FontTypeDefinition;
	}
	export class HostConfig {
	    readonly hostCapabilities: HostCapabilities;
	    private _legacyFontType;
	    choiceSetInputValueSeparator: string;
	    supportsInteractivity: boolean;
	    lineHeights?: ILineHeightDefinitions;
	    fontTypes: FontTypeSet;
	    readonly spacing: {
	        small: number;
	        default: number;
	        medium: number;
	        large: number;
	        extraLarge: number;
	        padding: number;
	    };
	    readonly separator: {
	        lineThickness: number;
	        lineColor: string;
	    };
	    readonly imageSizes: {
	        small: number;
	        medium: number;
	        large: number;
	    };
	    readonly containerStyles: ContainerStyleSet;
	    readonly actions: ActionsConfig;
	    readonly adaptiveCard: AdaptiveCardConfig;
	    readonly imageSet: ImageSetConfig;
	    readonly media: MediaConfig;
	    readonly factSet: FactSetConfig;
	    cssClassNamePrefix: string;
	    alwaysAllowBleed: boolean;
	    constructor(obj?: any);
	    getFontTypeDefinition(style?: Enums.FontType): FontTypeDefinition;
	    getEffectiveSpacing(spacing: Enums.Spacing): number;
	    paddingDefinitionToSpacingDefinition(paddingDefinition: Shared.PaddingDefinition): Shared.SpacingDefinition;
	    makeCssClassNames(...classNames: string[]): string[];
	    makeCssClassName(...classNames: string[]): string;
	    fontFamily: string;
	    readonly fontSizes: IFontSizeDefinitions;
	    readonly fontWeights: IFontWeightDefinitions;
	}

}
declare module 'adaptivecards/utils' {
	import * as Enums from 'adaptivecards/enums';
	import * as Shared from 'adaptivecards/shared';
	import { HostConfig } from 'adaptivecards/host-config';
	export function generateUniqueId(): string;
	export function isNullOrEmpty(value: string): boolean;
	export function appendChild(node: Node, child: Node): void;
	export function getStringValue(obj: any, defaultValue?: string): string;
	export function getNumberValue(obj: any, defaultValue?: number): number;
	export function getBoolValue(value: any, defaultValue: boolean): boolean;
	export function getEnumValue(targetEnum: {
	    [s: number]: string;
	}, name: string, defaultValue: number): number;
	export function setProperty(target: object, propertyName: string, propertyValue: any, defaultValue?: any): void;
	export function setNumberProperty(target: object, propertyName: string, propertyValue: number, defaultValue?: number): void;
	export function setEnumProperty(enumType: {
	    [s: number]: string;
	}, target: object, propertyName: string, propertyValue: number, defaultValue?: number): void;
	export function setArrayProperty(target: object, propertyName: string, propertyValue: any[]): void;
	export function parseHostConfigEnum(targetEnum: {
	    [s: number]: string;
	}, value: string | number, defaultValue: any): any;
	export function renderSeparation(hostConfig: HostConfig, separationDefinition: Shared.ISeparationDefinition, orientation: Enums.Orientation): HTMLElement;
	export function stringToCssColor(color: string): string;
	export function truncate(element: HTMLElement, maxHeight: number, lineHeight?: number): void;
	export function getFitStatus(element: HTMLElement, containerEnd: number): Enums.ContainerFitStatus;

}
declare module 'adaptivecards/text-formatters' {
	export function formatText(lang: string, text: string): string;

}
declare module 'adaptivecards/card-elements' {
	import * as Enums from 'adaptivecards/enums';
	import * as Shared from 'adaptivecards/shared';
	import * as HostConfig from 'adaptivecards/host-config';
	export function createActionInstance(parent: CardElement, json: any, forbiddenActionTypes: string[], allowFallback: boolean, errors: Array<HostConfig.IValidationError>): Action;
	export function createElementInstance(parent: CardElement, json: any, allowFallback: boolean, errors: Array<HostConfig.IValidationError>): CardElement;
	export abstract class SerializableObject {
	    private _rawProperties;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    setCustomProperty(name: string, value: any): void;
	    getCustomProperty(name: string): any;
	}
	export class ValidationFailure {
	    readonly cardObject: CardObject;
	    readonly errors: HostConfig.IValidationError[];
	    constructor(cardObject: CardObject);
	}
	export class ValidationResults {
	    private getFailureIndex;
	    readonly allIds: Shared.Dictionary<number>;
	    readonly failures: ValidationFailure[];
	    addFailure(cardObject: CardObject, error: HostConfig.IValidationError): void;
	}
	export abstract class CardObject extends SerializableObject {
	    abstract getJsonTypeName(): string;
	    abstract shouldFallback(): boolean;
	    abstract setParent(parent: CardElement): any;
	    id: string;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    validateProperties(): ValidationResults;
	}
	export type CardElementHeight = "auto" | "stretch";
	export abstract class CardElement extends CardObject {
	    private _shouldFallback;
	    private _lang;
	    private _hostConfig?;
	    private _parent;
	    private _renderedElement;
	    private _separatorElement;
	    private _isVisible;
	    private _truncatedDueToOverflow;
	    private _defaultRenderedElementDisplayMode;
	    private _padding;
	    private internalRenderSeparator;
	    private updateRenderedElementVisibility;
	    private hideElementDueToOverflow;
	    private showElementHiddenDueToOverflow;
	    private handleOverflow;
	    private resetOverflow;
	    protected createPlaceholderElement(): HTMLElement;
	    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
	    protected abstract internalRender(): HTMLElement;
	    protected overrideInternalRender(): HTMLElement;
	    protected applyPadding(): void;
	    protected truncateOverflow(maxHeight: number): boolean;
	    protected undoOverflowTruncation(): void;
	    protected getDefaultPadding(): Shared.PaddingDefinition;
	    protected getHasBackground(): boolean;
	    protected getPadding(): Shared.PaddingDefinition;
	    protected setPadding(value: Shared.PaddingDefinition): void;
	    protected readonly supportsMinHeight: boolean;
	    protected readonly useDefaultSizing: boolean;
	    protected readonly allowCustomPadding: boolean;
	    protected readonly separatorOrientation: Enums.Orientation;
	    protected readonly defaultStyle: string;
	    readonly requires: HostConfig.HostCapabilities;
	    horizontalAlignment?: Enums.HorizontalAlignment;
	    spacing: Enums.Spacing;
	    separator: boolean;
	    customCssSelector: string;
	    height: CardElementHeight;
	    minPixelHeight?: number;
	    abstract getJsonTypeName(): string;
	    asString(): string;
	    isBleeding(): boolean;
	    toJSON(): any;
	    setParent(value: CardElement): void;
	    getEffectiveStyle(): string;
	    getForbiddenElementTypes(): Array<string>;
	    getForbiddenActionTypes(): Array<any>;
	    getImmediateSurroundingPadding(result: Shared.PaddingDefinition, processTop?: boolean, processRight?: boolean, processBottom?: boolean, processLeft?: boolean): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getActionCount(): number;
	    getActionAt(index: number): Action;
	    remove(): boolean;
	    render(): HTMLElement;
	    updateLayout(processChildren?: boolean): void;
	    indexOf(cardElement: CardElement): number;
	    isDesignMode(): boolean;
	    isRendered(): boolean;
	    isFirstElement(element: CardElement): boolean;
	    isLastElement(element: CardElement): boolean;
	    isAtTheVeryLeft(): boolean;
	    isAtTheVeryRight(): boolean;
	    isAtTheVeryTop(): boolean;
	    isAtTheVeryBottom(): boolean;
	    isBleedingAtTop(): boolean;
	    isBleedingAtBottom(): boolean;
	    isLeftMostElement(element: CardElement): boolean;
	    isRightMostElement(element: CardElement): boolean;
	    isTopElement(element: CardElement): boolean;
	    isBottomElement(element: CardElement): boolean;
	    isHiddenDueToOverflow(): boolean;
	    getRootElement(): CardElement;
	    getParentContainer(): Container;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    getElementById(id: string): CardElement;
	    getActionById(id: string): Action;
	    shouldFallback(): boolean;
	    setShouldFallback(value: boolean): void;
	    getEffectivePadding(): Shared.PaddingDefinition;
	    lang: string;
	    hostConfig: HostConfig.HostConfig;
	    readonly index: number;
	    readonly isInteractive: boolean;
	    readonly isStandalone: boolean;
	    readonly isInline: boolean;
	    readonly parent: CardElement;
	    isVisible: boolean;
	    readonly hasVisibleSeparator: boolean;
	    readonly renderedElement: HTMLElement;
	    readonly separatorElement: HTMLElement;
	}
	export abstract class BaseTextBlock extends CardElement {
	    private _text;
	    private _selectAction;
	    protected getEffectiveStyleDefinition(): HostConfig.ContainerStyleDefinition;
	    protected getFontSize(fontType: HostConfig.FontTypeDefinition): number;
	    protected getColorDefinition(colorSet: HostConfig.ColorSetDefinition, color: Enums.TextColor): HostConfig.TextColorDefinition;
	    protected setText(value: string): void;
	    size: Enums.TextSize;
	    weight: Enums.TextWeight;
	    color: Enums.TextColor;
	    isSubtle: boolean;
	    fontType?: Enums.FontType;
	    asString(): string;
	    toJSON(): any;
	    applyStylesTo(targetElement: HTMLElement): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    readonly effectiveColor: Enums.TextColor;
	    text: string;
	    selectAction: Action;
	}
	export class TextBlock extends BaseTextBlock {
	    private _computedLineHeight;
	    private _originalInnerHtml;
	    private _processedText;
	    private _treatAsPlainText;
	    private restoreOriginalContent;
	    private truncateIfSupported;
	    protected setText(value: string): void;
	    protected getRenderedDomElementType(): string;
	    protected internalRender(): HTMLElement;
	    protected truncateOverflow(maxHeight: number): boolean;
	    protected undoOverflowTruncation(): void;
	    wrap: boolean;
	    maxLines: number;
	    useMarkdown: boolean;
	    toJSON(): any;
	    applyStylesTo(targetElement: HTMLElement): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getJsonTypeName(): string;
	    updateLayout(processChildren?: boolean): void;
	}
	export class TextRun extends BaseTextBlock {
	    protected internalRender(): HTMLElement;
	    italic: boolean;
	    strikethrough: boolean;
	    highlight: boolean;
	    applyStylesTo(targetElement: HTMLElement): void;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getJsonTypeName(): string;
	    readonly isStandalone: boolean;
	    readonly isInline: boolean;
	}
	export class RichTextBlock extends CardElement {
	    private _inlines;
	    private internalAddInline;
	    protected internalRender(): HTMLElement;
	    asString(): string;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    getJsonTypeName(): string;
	    getInlineCount(): number;
	    getInlineAt(index: number): CardElement;
	    addInline(inline: CardElement): void;
	    removeInline(inline: CardElement): boolean;
	}
	export class Fact extends SerializableObject {
	    name: string;
	    value: string;
	    constructor(name?: string, value?: string);
	    parse(json: any): void;
	    toJSON(): any;
	}
	export class FactSet extends CardElement {
	    protected readonly useDefaultSizing: boolean;
	    protected internalRender(): HTMLElement;
	    facts: Array<Fact>;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	}
	export class Image extends CardElement {
	    private _selectAction;
	    private parseDimension;
	    private applySize;
	    protected readonly useDefaultSizing: boolean;
	    protected internalRender(): HTMLElement;
	    style: Enums.ImageStyle;
	    backgroundColor: string;
	    url: string;
	    size: Enums.Size;
	    width: Shared.SizeAndUnit;
	    pixelWidth?: number;
	    pixelHeight?: number;
	    altText: string;
	    toJSON(): any;
	    getJsonTypeName(): string;
	    getActionById(id: string): Action;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    selectAction: Action;
	}
	export abstract class CardElementContainer extends CardElement {
	    private _selectAction;
	    protected isElementAllowed(element: CardElement, forbiddenElementTypes: Array<string>): boolean;
	    protected applyPadding(): void;
	    protected getSelectAction(): Action;
	    protected setSelectAction(value: Action): void;
	    protected readonly isSelectable: boolean;
	    abstract getItemCount(): number;
	    abstract getItemAt(index: number): CardElement;
	    abstract getFirstVisibleRenderedItem(): CardElement;
	    abstract getLastVisibleRenderedItem(): CardElement;
	    abstract removeItem(item: CardElement): boolean;
	    allowVerticalOverflow: boolean;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    render(): HTMLElement;
	    updateLayout(processChildren?: boolean): void;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    getElementById(id: string): CardElement;
	}
	export class ImageSet extends CardElementContainer {
	    private _images;
	    protected internalRender(): HTMLElement;
	    imageSize: Enums.Size;
	    getItemCount(): number;
	    getItemAt(index: number): CardElement;
	    getFirstVisibleRenderedItem(): CardElement;
	    getLastVisibleRenderedItem(): CardElement;
	    removeItem(item: CardElement): boolean;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    addImage(image: Image): void;
	    indexOf(cardElement: CardElement): number;
	}
	export class MediaSource extends SerializableObject {
	    mimeType: string;
	    url: string;
	    constructor(url?: string, mimeType?: string);
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	}
	export class Media extends CardElement {
	    static readonly supportedMediaTypes: string[];
	    private _selectedMediaType;
	    private _selectedSources;
	    private getPosterUrl;
	    private processSources;
	    private renderPoster;
	    private renderMediaPlayer;
	    protected internalRender(): HTMLElement;
	    static onPlay: (sender: Media) => void;
	    sources: Array<MediaSource>;
	    poster: string;
	    altText: string;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    getJsonTypeName(): string;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    readonly selectedMediaType: string;
	}
	export class InputValidationOptions extends SerializableObject {
	    necessity: Enums.InputValidationNecessity;
	    errorMessage: string;
	    parse(json: any): void;
	    toJSON(): any;
	}
	export abstract class Input extends CardElement implements Shared.IInput {
	    private _outerContainerElement;
	    private _inputControlContainerElement;
	    private _errorMessageElement;
	    private _renderedInputControlElement;
	    private _defaultValue;
	    protected readonly isNullable: boolean;
	    protected readonly renderedInputControlElement: HTMLElement;
	    protected readonly inputControlContainerElement: HTMLElement;
	    protected overrideInternalRender(): HTMLElement;
	    protected valueChanged(): void;
	    protected resetValidationFailureCue(): void;
	    protected showValidationErrorMessage(): void;
	    protected parseInputValue(value: string): string;
	    abstract readonly value: string;
	    onValueChanged: (sender: Input) => void;
	    readonly validation: InputValidationOptions;
	    title: string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    validateValue(): boolean;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getAllInputs(): Array<Input>;
	    defaultValue: string;
	    readonly isInteractive: boolean;
	}
	export class TextInput extends Input {
	    private _inlineAction;
	    protected internalRender(): HTMLElement;
	    protected overrideInternalRender(): HTMLElement;
	    maxLength: number;
	    isMultiline: boolean;
	    placeholder: string;
	    style: Enums.InputTextStyle;
	    getJsonTypeName(): string;
	    getActionById(id: string): Action;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    inlineAction: Action;
	    readonly value: string;
	}
	export class ToggleInput extends Input {
	    private _checkboxInputElement;
	    protected internalRender(): HTMLElement;
	    protected readonly isNullable: boolean;
	    valueOn: string;
	    valueOff: string;
	    wrap: boolean;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    readonly value: string;
	}
	export class Choice extends SerializableObject {
	    title: string;
	    value: string;
	    constructor(title?: string, value?: string);
	    parse(json: any): void;
	    toJSON(): any;
	}
	export class ChoiceSetInput extends Input {
	    private static uniqueCategoryCounter;
	    private static getUniqueCategoryName;
	    private _selectElement;
	    private _toggleInputs;
	    protected internalApplyAriaCurrent(): void;
	    protected internalRender(): HTMLElement;
	    choices: Array<Choice>;
	    isCompact: boolean;
	    isMultiSelect: boolean;
	    placeholder: string;
	    wrap: boolean;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    readonly value: string;
	}
	export class NumberInput extends Input {
	    private _numberInputElement;
	    private _min;
	    private _max;
	    protected internalRender(): HTMLElement;
	    placeholder: string;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    min: number;
	    max: number;
	    readonly value: string;
	    readonly valueAsNumber: number;
	}
	export class DateInput extends Input {
	    private _dateInputElement;
	    private _min;
	    private _max;
	    protected internalRender(): HTMLElement;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    min: string;
	    max: string;
	    readonly value: string;
	}
	export class TimeInput extends Input {
	    private _timeInputElement;
	    private _min;
	    private _max;
	    protected internalRender(): HTMLElement;
	    protected parseInputValue(value: string): string;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    min: string;
	    max: string;
	    readonly value: string;
	}
	export abstract class Action extends CardObject {
	    private _shouldFallback;
	    private _parent;
	    private _actionCollection;
	    private _renderedElement;
	    private setCollection;
	    protected addCssClasses(element: HTMLElement): void;
	    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
	    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
	    protected internalValidateInputs(referencedInputs: Shared.Dictionary<Input>): Array<Input>;
	    abstract getJsonTypeName(): string;
	    readonly requires: HostConfig.HostCapabilities;
	    title: string;
	    iconUrl: string;
	    style: string;
	    onExecute: (sender: Action) => void;
	    getAriaRole(): string;
	    getHref(): string;
	    toJSON(): any;
	    render(baseCssClass?: string): void;
	    setParent(value: CardElement): void;
	    execute(): void;
	    prepareForExecution(): boolean;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    remove(): boolean;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    getActionById(id: string): Action;
	    getReferencedInputs(): Shared.Dictionary<Input>;
	    validateInputs(): Input[];
	    shouldFallback(): boolean;
	    isPrimary: boolean;
	    readonly ignoreInputValidation: boolean;
	    readonly parent: CardElement;
	    readonly renderedElement: HTMLElement;
	}
	export class SubmitAction extends Action {
	    static readonly JsonTypeName: "Action.Submit";
	    private _isPrepared;
	    private _originalData;
	    private _processedData;
	    private _ignoreInputValidation;
	    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
	    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    ignoreInputValidation: boolean;
	    data: Object;
	}
	export class OpenUrlAction extends Action {
	    static readonly JsonTypeName: "Action.OpenUrl";
	    url: string;
	    getJsonTypeName(): string;
	    getAriaRole(): string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    getHref(): string;
	}
	export class ToggleVisibilityAction extends Action {
	    static readonly JsonTypeName: "Action.ToggleVisibility";
	    targetElements: {};
	    getJsonTypeName(): string;
	    execute(): void;
	    parse(json: any): void;
	    toJSON(): any;
	    addTargetElement(elementId: string, isVisible?: boolean): void;
	    removeTargetElement(elementId: any): void;
	}
	export class HttpHeader extends SerializableObject {
	    private _value;
	    name: string;
	    constructor(name?: string, value?: string);
	    parse(json: any): void;
	    toJSON(): any;
	    getReferencedInputs(inputs: Array<Input>, referencedInputs: Shared.Dictionary<Input>): void;
	    prepareForExecution(inputs: Shared.Dictionary<Input>): void;
	    value: string;
	}
	export class HttpAction extends Action {
	    static readonly JsonTypeName: "Action.Http";
	    private _url;
	    private _body;
	    private _headers;
	    private _ignoreInputValidation;
	    protected internalGetReferencedInputs(allInputs: Array<Input>): Shared.Dictionary<Input>;
	    protected internalPrepareForExecution(inputs: Shared.Dictionary<Input>): void;
	    method: string;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    ignoreInputValidation: boolean;
	    url: string;
	    body: string;
	    headers: Array<HttpHeader>;
	}
	export class ShowCardAction extends Action {
	    static readonly JsonTypeName: "Action.ShowCard";
	    protected addCssClasses(element: HTMLElement): void;
	    readonly card: AdaptiveCard;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    setParent(value: CardElement): void;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    getActionById(id: string): Action;
	}
	export class ActionSet extends CardElement {
	    private _actionCollection;
	    protected internalRender(): HTMLElement;
	    orientation?: Enums.Orientation;
	    constructor();
	    toJSON(): any;
	    isBleedingAtBottom(): boolean;
	    getJsonTypeName(): string;
	    getActionCount(): number;
	    getActionAt(index: number): Action;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    addAction(action: Action): void;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    readonly isInteractive: boolean;
	}
	export abstract class StylableCardElementContainer extends CardElementContainer {
	    private _style?;
	    private _bleed;
	    protected applyBackground(): void;
	    protected applyPadding(): void;
	    protected getHasBackground(): boolean;
	    protected getDefaultPadding(): Shared.PaddingDefinition;
	    protected getHasExpandedAction(): boolean;
	    protected getBleed(): boolean;
	    protected setBleed(value: boolean): void;
	    protected readonly renderedActionCount: number;
	    protected readonly hasExplicitStyle: boolean;
	    protected readonly allowCustomStyle: boolean;
	    protected readonly supportsMinHeight: boolean;
	    isBleeding(): boolean;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    render(): HTMLElement;
	    getEffectiveStyle(): string;
	    style: string;
	}
	export class BackgroundImage extends SerializableObject {
	    private static readonly defaultFillMode;
	    private static readonly defaultHorizontalAlignment;
	    private static readonly defaultVerticalAlignment;
	    url: string;
	    fillMode: Enums.FillMode;
	    horizontalAlignment: Enums.HorizontalAlignment;
	    verticalAlignment: Enums.VerticalAlignment;
	    reset(): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    toJSON(): any;
	    apply(element: HTMLElement): void;
	    isValid(): boolean;
	}
	export class Container extends StylableCardElementContainer {
	    private _items;
	    private _renderedItems;
	    private insertItemAt;
	    protected supportsExcplitiHeight(): boolean;
	    protected getItemsCollectionPropertyName(): string;
	    protected applyBackground(): void;
	    protected internalRender(): HTMLElement;
	    protected truncateOverflow(maxHeight: number): boolean;
	    protected undoOverflowTruncation(): void;
	    protected getHasBackground(): boolean;
	    protected readonly isSelectable: boolean;
	    readonly backgroundImage: BackgroundImage;
	    verticalContentAlignment: Enums.VerticalAlignment;
	    rtl?: boolean;
	    toJSON(): any;
	    getItemCount(): number;
	    getItemAt(index: number): CardElement;
	    getFirstVisibleRenderedItem(): CardElement;
	    getLastVisibleRenderedItem(): CardElement;
	    getJsonTypeName(): string;
	    isFirstElement(element: CardElement): boolean;
	    isLastElement(element: CardElement): boolean;
	    isRtl(): boolean;
	    isBleedingAtTop(): boolean;
	    isBleedingAtBottom(): boolean;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    indexOf(cardElement: CardElement): number;
	    addItem(item: CardElement): void;
	    insertItemBefore(item: CardElement, insertBefore: CardElement): void;
	    insertItemAfter(item: CardElement, insertAfter: CardElement): void;
	    removeItem(item: CardElement): boolean;
	    clear(): void;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    getActionById(id: string): Action;
	    padding: Shared.PaddingDefinition;
	    selectAction: Action;
	    bleed: boolean;
	}
	export type ColumnWidth = Shared.SizeAndUnit | "auto" | "stretch";
	export class Column extends Container {
	    private _computedWeight;
	    protected adjustRenderedElementSize(renderedElement: HTMLElement): void;
	    protected readonly separatorOrientation: Enums.Orientation;
	    width: ColumnWidth;
	    constructor(width?: ColumnWidth);
	    getJsonTypeName(): string;
	    toJSON(): any;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    readonly hasVisibleSeparator: boolean;
	    readonly isStandalone: boolean;
	}
	export class ColumnSet extends StylableCardElementContainer {
	    private _columns;
	    private _renderedColumns;
	    private createColumnInstance;
	    protected internalRender(): HTMLElement;
	    protected truncateOverflow(maxHeight: number): boolean;
	    protected undoOverflowTruncation(): void;
	    protected readonly isSelectable: boolean;
	    toJSON(): any;
	    isFirstElement(element: CardElement): boolean;
	    isBleedingAtTop(): boolean;
	    isBleedingAtBottom(): boolean;
	    getCount(): number;
	    getItemCount(): number;
	    getFirstVisibleRenderedItem(): CardElement;
	    getLastVisibleRenderedItem(): CardElement;
	    getColumnAt(index: number): Column;
	    getItemAt(index: number): CardElement;
	    getJsonTypeName(): string;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    internalValidateProperties(context: ValidationResults): void;
	    addColumn(column: Column): void;
	    removeItem(item: CardElement): boolean;
	    indexOf(cardElement: CardElement): number;
	    isLeftMostElement(element: CardElement): boolean;
	    isRightMostElement(element: CardElement): boolean;
	    isTopElement(element: CardElement): boolean;
	    isBottomElement(element: CardElement): boolean;
	    getActionById(id: string): Action;
	    bleed: boolean;
	    padding: Shared.PaddingDefinition;
	    selectAction: Action;
	}
	export interface ITypeRegistration<T> {
	    typeName: string;
	    createInstance: () => T;
	}
	export abstract class ContainerWithActions extends Container {
	    private _actionCollection;
	    protected internalRender(): HTMLElement;
	    protected getHasExpandedAction(): boolean;
	    protected readonly renderedActionCount: number;
	    protected readonly renderIfEmpty: boolean;
	    constructor();
	    toJSON(): any;
	    getActionCount(): number;
	    getActionAt(index: number): Action;
	    getActionById(id: string): Action;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    internalValidateProperties(context: ValidationResults): void;
	    isLastElement(element: CardElement): boolean;
	    addAction(action: Action): void;
	    clear(): void;
	    getAllInputs(): Array<Input>;
	    getResourceInformation(): Array<Shared.IResourceInformation>;
	    isBleedingAtBottom(): boolean;
	    readonly isStandalone: boolean;
	}
	export abstract class TypeRegistry<T> {
	    private _items;
	    private findTypeRegistration;
	    constructor();
	    clear(): void;
	    abstract reset(): any;
	    registerType(typeName: string, createInstance: () => T): void;
	    unregisterType(typeName: string): void;
	    createInstance(typeName: string): T;
	    getItemCount(): number;
	    getItemAt(index: number): ITypeRegistration<T>;
	}
	export class ElementTypeRegistry extends TypeRegistry<CardElement> {
	    reset(): void;
	}
	export class ActionTypeRegistry extends TypeRegistry<Action> {
	    reset(): void;
	}
	export interface IMarkdownProcessingResult {
	    didProcess: boolean;
	    outputHtml?: any;
	}
	export class AdaptiveCard extends ContainerWithActions {
	    private static currentVersion;
	    static useAdvancedTextBlockTruncation: boolean;
	    static useAdvancedCardBottomTruncation: boolean;
	    static useMarkdownInRadioButtonAndCheckbox: boolean;
	    static allowMarkForTextHighlighting: boolean;
	    static alwaysBleedSeparators: boolean;
	    static enableFullJsonRoundTrip: boolean;
	    static useBuiltInInputValidation: boolean;
	    static displayInputValidationErrors: boolean;
	    static readonly elementTypeRegistry: ElementTypeRegistry;
	    static readonly actionTypeRegistry: ActionTypeRegistry;
	    static onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
	    static onExecuteAction: (action: Action) => void;
	    static onElementVisibilityChanged: (element: CardElement) => void;
	    static onImageLoaded: (image: Image) => void;
	    static onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
	    static onInputValueChanged: (input: Input) => void;
	    static onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
	    static onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
	    static onParseError: (error: HostConfig.IValidationError) => void;
	    static onProcessMarkdown: (text: string, result: IMarkdownProcessingResult) => void;
	    static processMarkdown: (text: string) => string;
	    static applyMarkdown(text: string): IMarkdownProcessingResult;
	    private _cardTypeName?;
	    private _fallbackCard;
	    private isVersionSupported;
	    protected getItemsCollectionPropertyName(): string;
	    protected internalRender(): HTMLElement;
	    protected getHasBackground(): boolean;
	    protected getDefaultPadding(): Shared.PaddingDefinition;
	    protected readonly renderIfEmpty: boolean;
	    protected readonly bypassVersionCheck: boolean;
	    protected readonly allowCustomStyle: boolean;
	    protected readonly hasBackground: boolean;
	    onAnchorClicked: (element: CardElement, anchor: HTMLAnchorElement) => boolean;
	    onExecuteAction: (action: Action) => void;
	    onElementVisibilityChanged: (element: CardElement) => void;
	    onImageLoaded: (image: Image) => void;
	    onInlineCardExpanded: (action: ShowCardAction, isExpanded: boolean) => void;
	    onInputValueChanged: (input: Input) => void;
	    onParseElement: (element: CardElement, json: any, errors?: Array<HostConfig.IValidationError>) => void;
	    onParseAction: (element: Action, json: any, errors?: Array<HostConfig.IValidationError>) => void;
	    version?: HostConfig.Version;
	    fallbackText: string;
	    speak: string;
	    designMode: boolean;
	    getJsonTypeName(): string;
	    toJSON(): any;
	    internalValidateProperties(context: ValidationResults): void;
	    parse(json: any, errors?: Array<HostConfig.IValidationError>): void;
	    render(target?: HTMLElement): HTMLElement;
	    updateLayout(processChildren?: boolean): void;
	    shouldFallback(): boolean;
	    readonly hasVisibleSeparator: boolean;
	}

}
declare module 'adaptivecards/schema' {
	export type Size = "auto" | "stretch" | "small" | "medium" | "large";
	export type TextSize = "small" | "default" | "medium" | "large" | "extraLarge";
	export type HorizontalAlignment = "left" | "center" | "right";
	export type VerticalAlignment = "top" | "center" | "bottom";
	export type Spacing = "none" | "small" | "default" | "medium" | "large" | "extraLarge" | "padding";
	export type TextWeight = "lighter" | "default" | "bolder";
	export type TextColor = "default" | "dark" | "light" | "accent" | "good" | "warning" | "attention";
	export type ContainerStyle = "default" | "emphasis";
	export type ImageStyle = "default" | "person";
	export interface IAction {
	    id: string;
	    title?: string;
	}
	export interface ISubmitAction extends IAction {
	    type: "Action.Submit";
	    data?: any;
	}
	export interface IOpenUrlAction extends IAction {
	    type: "Action.OpenUrl";
	    url: string;
	}
	export interface IShowCardAction extends IAction {
	    type: "Action.ShowCard";
	    card: IAdaptiveCard;
	}
	export interface ICardElement {
	    id?: string;
	    speak?: string;
	    horizontalAlignment?: HorizontalAlignment;
	    spacing?: Spacing;
	    separator?: boolean;
	    height?: "auto" | "stretch";
	    [propName: string]: any;
	}
	export interface IBackgroundImage {
	    url: string;
	}
	export interface ITextBlock extends ICardElement {
	    type: "TextBlock";
	    size?: TextSize;
	    weight?: TextWeight;
	    color?: TextColor;
	    text: string;
	    isSubtle?: boolean;
	    wrap?: boolean;
	    maxLines?: number;
	}
	export interface IContainer extends ICardElement {
	    type: "Container";
	    backgroundImage?: IBackgroundImage | string;
	    style?: ContainerStyle;
	    verticalContentAlignment?: VerticalAlignment;
	    selectAction?: IAction;
	    items?: ICardElement[];
	}
	export interface IColumn extends ICardElement {
	    backgroundImage?: IBackgroundImage | string;
	    style?: ContainerStyle;
	    verticalContentAlignment?: VerticalAlignment;
	    selectAction?: IAction;
	    items?: ICardElement[];
	    width?: number | "auto" | "stretch" | "auto";
	}
	export interface IColumnSet extends ICardElement {
	    type: "ColumnSet";
	    columns: IColumn[];
	}
	export interface IFact {
	    title: string;
	    value: string;
	    speak?: string;
	}
	export interface IFactSet extends ICardElement {
	    type: "FactSet";
	    facts: IFact[];
	}
	export interface IImage extends ICardElement {
	    type: "Image";
	    altText?: string;
	    selectAction?: IAction;
	    size?: Size;
	    style?: ImageStyle;
	    url: string;
	}
	export interface IImageSet extends ICardElement {
	    type: "ImageSet";
	    images: IImage[];
	    size?: Size;
	}
	export interface IInput extends ICardElement {
	    id: string;
	    value?: string;
	}
	export interface IDateInput extends IInput {
	    type: "Input.Date";
	    min?: string;
	    max?: string;
	    placeholder?: string;
	}
	export interface ITimeInput extends IInput {
	    type: "Input.Time";
	    min?: string;
	    max?: string;
	    placeholder?: string;
	}
	export interface INumberInput extends IInput {
	    type: "Input.Number";
	    min?: number;
	    max?: number;
	    placeholder?: string;
	}
	export interface ITextInput extends IInput {
	    type: "Input.Text";
	    isMultiline?: boolean;
	    maxLength?: number;
	    placeholder?: string;
	}
	export interface IToggleInput extends IInput {
	    type: "Input.Toggle";
	    title: string;
	    valueOn?: string;
	    valueOff?: string;
	}
	export interface IChoice {
	    title: string;
	    value: string;
	}
	export interface IChoiceSetInput extends IInput {
	    type: "Input.ChoiceSet";
	    isMultiSelect?: boolean;
	    style?: "expanded" | "compact";
	    placeholder?: string;
	    choices: IChoice[];
	}
	export interface IVersion {
	    major: number;
	    minor: number;
	}
	export interface IAdaptiveCard extends ICardElement {
	    type: "AdaptiveCard";
	    version?: IVersion | string;
	    backgroundImage?: IBackgroundImage | string;
	    body?: (ITextBlock | IImage | IImageSet | IFactSet | IColumnSet | IContainer)[];
	    actions?: (ISubmitAction | IOpenUrlAction | IShowCardAction)[];
	    speak?: string;
	}

}
declare module 'adaptivecards/adaptivecards' {
	export * from 'adaptivecards/card-elements';
	export * from 'adaptivecards/enums';
	export * from 'adaptivecards/host-config';
	export * from 'adaptivecards/shared';
	export * from 'adaptivecards/utils';
	export { IAdaptiveCard, ICardElement } from 'adaptivecards/schema';

}
