> Text and Speak should get the same result
# AskForAge.prompt
[Activity
    Text = ${GetAge()}

> this is a comment about this specific property
    Speak = ${GetAge()}
]


# GetAge
- how old are you?
- what's your age?


> With '|' you are making attachments a list. 
# AskForAge.prompt2
[Activity
    Text = ${GetAge()}
    SuggestedActions = 10 | 20 | 30
]


> You can use '\' as an escape character
> \${GetAge()} would not be evaluated as expression, would be parsed as '${getAge()}' string
# AskForAge.prompt3
[Activity
        Text = \${GetAge()}
        Suggestions = 10 \| cards | 20 \| cards
]


> Tab and whitespace is support in front of property
> can access the property of another structured result
> and whitespace inb front of the end square bracket is allowed
# T1
[Activity
		Text = ${T2()}
		Speak = hello world ${T3().speak}
    ]


# T2
- This is awesome


# T3
[Activity
    Speak = I can also speak!
]


> use a pure to get the structured, but remember, with the same property, original one would be hold
> so, the result of Text would be 'cool' but not 'food'
# ST1
[MyStruct
    Text = cool
    ${ST2()}
]


# ST2
[MyStruct
    Speak = beta
    Text = food
]


> each item can also be a structure
# AskForColor
[Activity
    SuggestedActions = ${ST2()} | ${T3()}
]


> if you use multi structures in a normal template body, the result would be a string result
> but not a list with two items
# MultiExpression
- ${T3()} ${T4()}


> template can ref to another steuctured template
# StructuredTemplateRef
- ${T4()}


# T4
[MyStruct
    Text = hi
]


> if you want to re-use the structured, foreach function is a good way
# MultiStructuredRef
[MyStruct
    list = ${foreach(createArray('hello','world'), x, T5(x))}
]


# T5(text)
[SubStruct
    Text = ${text}
]


# templateWithSquareBrackets(manufacturer)
[Struct
    Text = ${manufacturer['Name']}
]  


# ExpanderT1
[MyStruct
    Text = ${ExpanderT2()}
    ${ExpanderT3()}
]


# ExpanderT2
- Hi
- Hello

# ExpanderT3
[MyStruct
    Speak = ${GetAge()}
    Text = food
]


> treat everything after the first = as value.
# ValueWithEqualsMark
[Activity
    Text = Hello! welcome back. I have your name = ${name}
]