// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator, __values } from "tslib";
import { isTokenCredential, isNode, getDefaultProxySettings } from "@azure/core-http";
import { CanonicalCode } from "@opentelemetry/api";
import { Service } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import "@azure/core-paging";
import { appendToURLPath, extractConnectionStringParts } from "./utils/utils.common";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { createSpan } from "./utils/tracing";
import { QueueClient } from "./QueueClient";
/**
 * A QueueServiceClient represents a URL to the Azure Storage Queue service allowing you
 * to manipulate queues.
 *
 * @export
 * @class QueueServiceClient
 */
var QueueServiceClient = /** @class */ (function (_super) {
    __extends(QueueServiceClient, _super);
    function QueueServiceClient(url, credentialOrPipeline, options) {
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if ((isNode && credentialOrPipeline instanceof StorageSharedKeyCredential) ||
            credentialOrPipeline instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipeline)) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second paramter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.serviceContext = new Service(_this.storageClientContext);
        return _this;
    }
    /**
     * Creates an instance of QueueServiceClient.
     *
     * @param {string} connectionString Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param {StoragePipelineOptions} [options] Options to configure the HTTP pipeline.
     * @returns {QueueServiceClient} A new QueueServiceClient object from the given connection string.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.fromConnectionString = function (connectionString, options) {
        options = options || {};
        var extractedCreds = extractConnectionStringParts(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
            if (isNode) {
                var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                var pipeline = newPipeline(sharedKeyCredential, options);
                return new QueueServiceClient(extractedCreds.url, pipeline);
            }
            else {
                throw new Error("Account connection string is only supported in Node.js environment");
            }
        }
        else if (extractedCreds.kind === "SASConnString") {
            var pipeline = newPipeline(new AnonymousCredential(), options);
            return new QueueServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        }
        else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
    };
    /**
     * Creates a {@link QueueClient} object.
     *
     * @param {string} queueName
     * @returns {QueueClient} a new QueueClient
     * @memberof QueueServiceClient
     *
     * Example usage:
     *
     * ```js
     * const queueClient = queueServiceClient.getQueueClient("<new queue name>");
     * const createQueueResponse = await queueClient.create();
     * ```
     */
    QueueServiceClient.prototype.getQueueClient = function (queueName) {
        return new QueueClient(appendToURLPath(this.url, queueName), this.pipeline);
    };
    /**
     * Returns a list of the queues under the specified account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-queues1
     *
     * @param {string} [marker] A string value that identifies the portion of
     *                        the list of queues to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all queues remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param {ServiceListQueuesSegmentOptions} [options] Options to list queues operation.
     * @returns {Promise<ServiceListQueuesSegmentResponse>} Response data for the list queues segment operation.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.listQueuesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-listQueuesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.listQueuesSegment({
                                abortSignal: options.abortSignal,
                                marker: marker,
                                maxPageSize: options.maxPageSize,
                                prefix: options.prefix,
                                include: options.include === undefined ? undefined : [options.include],
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link ServiceListQueuesSegmentResponse} objects
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                        the list of queues to be returned with the next listing operation. The
     *                        operation returns the continuationToken value within the response body if the
     *                        listing operation did not return all queues remaining to be listed
     *                        with the current page. The continuationToken value can be used as the value for
     *                        the marker parameter in a subsequent call to request the next page of list
     *                        items. The marker value is opaque to the client.
     * @param {ServiceListQueuesSegmentOptions} [options] Options to list queues operation.
     * @returns {AsyncIterableIterator<ServiceListQueuesSegmentResponse>}
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.listSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listSegments_1() {
            var listQueuesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listQueuesSegment(marker, options))];
                    case 2:
                        listQueuesResponse = _a.sent();
                        marker = listQueuesResponse.continuationToken;
                        return [4 /*yield*/, __await(listQueuesResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link QueueItem} objects
     *
     * @private
     * @param {ServiceListQueuesSegmentOptions} [options] Options to list queues operation.
     * @returns {AsyncIterableIterator<QueueItem>}
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listItems_1() {
            var marker, _a, _b, segment, e_2_1;
            var e_2, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 8, 9, 14]);
                        _a = __asyncValues(this.listSegments(marker, options));
                        _d.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 7];
                        segment = _b.value;
                        return [5 /*yield**/, __values(__asyncDelegator(__asyncValues(segment.queueItems)))];
                    case 4: return [4 /*yield*/, __await.apply(void 0, [_d.sent()])];
                    case 5:
                        _d.sent();
                        _d.label = 6;
                    case 6: return [3 /*break*/, 2];
                    case 7: return [3 /*break*/, 14];
                    case 8:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 14];
                    case 9:
                        _d.trys.push([9, , 12, 13]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 11];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 10:
                        _d.sent();
                        _d.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 13: return [7 /*endfinally*/];
                    case 14: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the queues
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the queues in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const item of queueServiceClient.listQueues()) {
     *   console.log(`Queue${i}: ${item.name}`);
     *   i++;
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iterator = queueServiceClient.listQueues();
     * let item = await iterator.next();
     * while (!item.done) {
     *   console.log(`Queue${i}: ${iterator.value.name}`);
     *   i++;
     *   item = await iterator.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const item2 of queueServiceClient.listQueues().byPage({ maxPageSize: 20 })) {
     *   if (item2.queueItems) {
     *     for (const queueItem of item2.queueItems) {
     *       console.log(`Queue${i}: ${queueItem.name}`);
     *       i++;
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = queueServiceClient.listQueues().byPage({ maxPageSize: 2 });
     * let item = (await iterator.next()).value;
     *
     * // Prints 2 queue names
     * if (item.queueItems) {
     *   for (const queueItem of item.queueItems) {
     *     console.log(`Queue${i}: ${queueItem.name}`);
     *     i++;
     *   }
     * }
     * // Gets next marker
     * let marker = item.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = queueServiceClient.listQueues().byPage({ continuationToken: marker, maxPageSize: 10 });
     * item = (await iterator.next()).value;
     *
     * // Prints 10 queue names
     * if (item.queueItems) {
     *   for (const queueItem of item.queueItems) {
     *     console.log(`Queue${i}: ${queueItem.name}`);
     *     i++;
     *   }
     * }
     * ```
     *
     * @param {ServiceListQueuesOptions} [options] Options to list queues operation.
     * @memberof QueueServiceClient
     * @returns {PagedAsyncIterableIterator<QueueItem, ServiceListQueuesSegmentResponse>} An asyncIterableIterator that supports paging.
     */
    QueueServiceClient.prototype.listQueues = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        var updatedOptions = __assign(__assign({}, options), (options.includeMetadata ? { include: "metadata" } : {}));
        // AsyncIterableIterator to iterate over queues
        var iter = this.listItems(updatedOptions);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return iter.next();
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, __assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
            },
            _a;
    };
    /**
     * Gets the properties of a storage account’s Queue service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-service-properties
     *
     * @param {ServiceGetPropertiesOptions} [options] Options to get properties operation.
     * @returns {Promise<ServiceGetPropertiesResponse>} Response data including the queue service properties.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.getProperties({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties for a storage account’s Queue service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-queue-service-properties
     *
     * @param {QueueServiceProperties} properties
     * @param {ServiceGetPropertiesOptions} [options] Options to set properties operation.
     * @returns {Promise<ServiceSetPropertiesResponse>} Response data for the Set Properties operation.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.setProperties = function (properties, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-setProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.setProperties(properties, {
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves statistics related to replication for the Queue service. It is only
     * available on the secondary location endpoint when read-access geo-redundant
     * replication is enabled for the storage account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-queue-service-stats
     *
     * @param {ServiceGetStatisticsOptions} [options] Options to get statistics operation.
     * @returns {Promise<ServiceGetStatisticsResponse>} Response data for get statistics the operation.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.getStatistics = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-getStatistics", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.serviceContext.getStatistics({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new queue under the specified account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-queue4
     *
     * @param {string} queueName name of the queue to create
     * @param {QueueCreateOptions} [options] Options to Queue create operation.
     * @returns {Promise<QueueCreateResponse>} Response data for the Queue create operation.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.createQueue = function (queueName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-createQueue", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getQueueClient(queueName).create(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deletes the specified queue permanently.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-queue3
     *
     * @param {string} queueName name of the queue to delete.
     * @param {QueueDeleteOptions} [options] Options to Queue delete operation.
     * @returns {Promise<QueueDeleteResponse>} Response data for the Queue delete operation.
     * @memberof QueueServiceClient
     */
    QueueServiceClient.prototype.deleteQueue = function (queueName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("QueueServiceClient-deleteQueue", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getQueueClient(queueName).delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return QueueServiceClient;
}(StorageClient));
export { QueueServiceClient };
//# sourceMappingURL=QueueServiceClient.js.map