/*! @azure/msal-browser v2.17.0 2021-09-08 */
'use strict';
import { __extends, __awaiter, __generator, __assign, __spread } from '../_virtual/_tslib.js';
import { Constants, UrlString, AuthorizationCodeClient, AuthorityFactory, ServerTelemetryManager, ProtocolUtils, ResponseMode, StringUtils, PersistentCacheKeys, IdToken, AuthenticationScheme } from '@azure/msal-common';
import { BaseInteractionClient } from './BaseInteractionClient.js';
import { BrowserConstants } from '../utils/BrowserConstants.js';
import { version } from '../packageMetadata.js';
import { BrowserAuthError } from '../error/BrowserAuthError.js';
import { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';
import { BrowserUtils } from '../utils/BrowserUtils.js';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Defines the class structure and helper functions used by the "standard", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))
 */
var StandardInteractionClient = /** @class */ (function (_super) {
    __extends(StandardInteractionClient, _super);
    function StandardInteractionClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, correlationId) {
        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, correlationId) || this;
        _this.navigationClient = navigationClient;
        return _this;
    }
    /**
     * Generates an auth code request tied to the url request.
     * @param request
     */
    StandardInteractionClient.prototype.initializeAuthorizationCodeRequest = function (request) {
        return __awaiter(this, void 0, void 0, function () {
            var generatedPkceParams, authCodeRequest;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.verbose("initializeAuthorizationRequest called", request.correlationId);
                        return [4 /*yield*/, this.browserCrypto.generatePkceCodes()];
                    case 1:
                        generatedPkceParams = _a.sent();
                        authCodeRequest = __assign(__assign({}, request), { redirectUri: request.redirectUri, code: "", codeVerifier: generatedPkceParams.verifier });
                        request.codeChallenge = generatedPkceParams.challenge;
                        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;
                        return [2 /*return*/, authCodeRequest];
                }
            });
        });
    };
    /**
     * Initializer for the logout request.
     * @param logoutRequest
     */
    StandardInteractionClient.prototype.initializeLogoutRequest = function (logoutRequest) {
        this.logger.verbose("initializeLogoutRequest called", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);
        // Check if interaction is in progress. Throw error if true.
        if (this.browserStorage.isInteractionInProgress()) {
            throw BrowserAuthError.createInteractionInProgressError();
        }
        var validLogoutRequest = __assign({ correlationId: this.browserCrypto.createNewGuid() }, logoutRequest);
        /*
         * Only set redirect uri if logout request isn't provided or the set uri isn't null.
         * Otherwise, use passed uri, config, or current page.
         */
        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {
            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {
                this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", validLogoutRequest.correlationId);
                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());
            }
            else if (this.config.auth.postLogoutRedirectUri === null) {
                this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", validLogoutRequest.correlationId);
            }
            else if (this.config.auth.postLogoutRedirectUri) {
                this.logger.verbose("Setting postLogoutRedirectUri to configured uri", validLogoutRequest.correlationId);
                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());
            }
            else {
                this.logger.verbose("Setting postLogoutRedirectUri to current page", validLogoutRequest.correlationId);
                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());
            }
        }
        else {
            this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", validLogoutRequest.correlationId);
        }
        return validLogoutRequest;
    };
    /**
     * Creates an Authorization Code Client with the given authority, or the default authority.
     * @param serverTelemetryManager
     * @param authorityUrl
     */
    StandardInteractionClient.prototype.createAuthCodeClient = function (serverTelemetryManager, authorityUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var clientConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, authorityUrl)];
                    case 1:
                        clientConfig = _a.sent();
                        return [2 /*return*/, new AuthorizationCodeClient(clientConfig)];
                }
            });
        });
    };
    /**
     * Creates a Client Configuration object with the given request authority, or the default authority.
     * @param serverTelemetryManager
     * @param requestAuthority
     * @param requestCorrelationId
     */
    StandardInteractionClient.prototype.getClientConfiguration = function (serverTelemetryManager, requestAuthority) {
        return __awaiter(this, void 0, void 0, function () {
            var discoveredAuthority;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.verbose("getClientConfiguration called");
                        return [4 /*yield*/, this.getDiscoveredAuthority(requestAuthority)];
                    case 1:
                        discoveredAuthority = _a.sent();
                        return [2 /*return*/, {
                                authOptions: {
                                    clientId: this.config.auth.clientId,
                                    authority: discoveredAuthority,
                                    clientCapabilities: this.config.auth.clientCapabilities
                                },
                                systemOptions: {
                                    tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
                                    preventCorsPreflight: true
                                },
                                loggerOptions: {
                                    loggerCallback: this.config.system.loggerOptions.loggerCallback,
                                    piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
                                    logLevel: this.config.system.loggerOptions.logLevel,
                                    correlationId: this.correlationId
                                },
                                cryptoInterface: this.browserCrypto,
                                networkInterface: this.networkClient,
                                storageInterface: this.browserStorage,
                                serverTelemetryManager: serverTelemetryManager,
                                libraryInfo: {
                                    sku: BrowserConstants.MSAL_SKU,
                                    version: version,
                                    cpu: "",
                                    os: ""
                                }
                            }];
                }
            });
        });
    };
    /**
     * @param hash
     * @param interactionType
     */
    StandardInteractionClient.prototype.validateAndExtractStateFromHash = function (hash, interactionType, requestCorrelationId) {
        this.logger.verbose("validateAndExtractStateFromHash called", requestCorrelationId);
        // Deserialize hash fragment response parameters.
        var serverParams = UrlString.getDeserializedHash(hash);
        if (!serverParams.state) {
            throw BrowserAuthError.createHashDoesNotContainStateError();
        }
        var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);
        if (!platformStateObj) {
            throw BrowserAuthError.createUnableToParseStateError();
        }
        if (platformStateObj.interactionType !== interactionType) {
            throw BrowserAuthError.createStateInteractionTypeMismatchError();
        }
        this.logger.verbose("Returning state from hash", requestCorrelationId);
        return serverParams.state;
    };
    /**
     * Used to get a discovered version of the default authority.
     * @param requestAuthority
     * @param requestCorrelationId
     */
    StandardInteractionClient.prototype.getDiscoveredAuthority = function (requestAuthority) {
        return __awaiter(this, void 0, void 0, function () {
            var authorityOptions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.verbose("getDiscoveredAuthority called");
                        authorityOptions = {
                            protocolMode: this.config.auth.protocolMode,
                            knownAuthorities: this.config.auth.knownAuthorities,
                            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
                            authorityMetadata: this.config.auth.authorityMetadata
                        };
                        if (!requestAuthority) return [3 /*break*/, 2];
                        this.logger.verbose("Creating discovered authority with request authority");
                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(requestAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        this.logger.verbose("Creating discovered authority with configured authority");
                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, authorityOptions)];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     *
     * @param apiId
     * @param correlationId
     * @param forceRefresh
     */
    StandardInteractionClient.prototype.initializeServerTelemetryManager = function (apiId, forceRefresh) {
        this.logger.verbose("initializeServerTelemetryManager called");
        var telemetryPayload = {
            clientId: this.config.auth.clientId,
            correlationId: this.correlationId,
            apiId: apiId,
            forceRefresh: forceRefresh || false,
            wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
            wrapperVer: this.browserStorage.getWrapperMetadata()[1]
        };
        return new ServerTelemetryManager(telemetryPayload, this.browserStorage);
    };
    /**
     * Helper to validate app environment before making a request.
     * @param request
     * @param interactionType
     */
    StandardInteractionClient.prototype.preflightInteractiveRequest = function (request, interactionType) {
        this.logger.verbose("preflightInteractiveRequest called, validating app environment", request === null || request === void 0 ? void 0 : request.correlationId);
        // block the reload if it occurred inside a hidden iframe
        BrowserUtils.blockReloadInHiddenIframes();
        // Check if interaction is in progress. Throw error if true.
        if (this.browserStorage.isInteractionInProgress(false)) {
            throw BrowserAuthError.createInteractionInProgressError();
        }
        return this.initializeAuthorizationRequest(request, interactionType);
    };
    /**
     * Helper to initialize required request parameters for interactive APIs and ssoSilent()
     * @param request
     * @param interactionType
     */
    StandardInteractionClient.prototype.initializeAuthorizationRequest = function (request, interactionType) {
        this.logger.verbose("initializeAuthorizationRequest called");
        var redirectUri = this.getRedirectUri(request.redirectUri);
        var browserState = {
            interactionType: interactionType
        };
        var state = ProtocolUtils.setRequestState(this.browserCrypto, (request && request.state) || "", browserState);
        var validatedRequest = __assign(__assign({}, this.initializeBaseRequest(request)), { redirectUri: redirectUri, state: state, nonce: request.nonce || this.browserCrypto.createNewGuid(), responseMode: ResponseMode.FRAGMENT });
        var account = request.account || this.browserStorage.getActiveAccount();
        if (account) {
            this.logger.verbose("Setting validated request account");
            this.logger.verbosePii("Setting validated request account: " + account);
            validatedRequest.account = account;
        }
        // Check for ADAL/MSAL v1 SSO
        if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {
            // Only check for adal/msal token if no SSO params are being used
            var adalIdTokenString = this.browserStorage.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);
            if (adalIdTokenString) {
                this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);
                this.logger.verbose("Cached ADAL id token retrieved.");
            }
            // Check for cached MSAL v1 id token
            var msalIdTokenString = this.browserStorage.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);
            if (msalIdTokenString) {
                this.browserStorage.removeItem(this.browserStorage.generateCacheKey(PersistentCacheKeys.ID_TOKEN));
                this.logger.verbose("Cached MSAL.js v1 id token retrieved");
            }
            var cachedIdTokenString = msalIdTokenString || adalIdTokenString;
            if (cachedIdTokenString) {
                var cachedIdToken = new IdToken(cachedIdTokenString, this.browserCrypto);
                if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {
                    this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint");
                    validatedRequest.loginHint = cachedIdToken.claims.preferred_username;
                }
                else if (cachedIdToken.claims && cachedIdToken.claims.upn) {
                    this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint");
                    validatedRequest.loginHint = cachedIdToken.claims.upn;
                }
                else {
                    this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.");
                }
            }
        }
        this.browserStorage.updateCacheEntries(validatedRequest.state, validatedRequest.nonce, validatedRequest.authority, validatedRequest.loginHint || "", validatedRequest.account || null);
        return validatedRequest;
    };
    /**
     * Initializer function for all request APIs
     * @param request
     */
    StandardInteractionClient.prototype.initializeBaseRequest = function (request) {
        this.logger.verbose("Initializing BaseAuthRequest");
        var authority = request.authority || this.config.auth.authority;
        var scopes = __spread(((request && request.scopes) || []));
        // Set authenticationScheme to BEARER if not explicitly set in the request
        if (!request.authenticationScheme) {
            request.authenticationScheme = AuthenticationScheme.BEARER;
            this.logger.verbose("Authentication Scheme wasn't explicitly set in request, defaulting to \"Bearer\" request");
        }
        else {
            this.logger.verbose("Authentication Scheme set to \"" + request.authenticationScheme + "\" as configured in Auth request");
        }
        var validatedRequest = __assign(__assign({}, request), { correlationId: this.correlationId, authority: authority,
            scopes: scopes });
        return validatedRequest;
    };
    /**
     *
     * Use to get the redirect uri configured in MSAL or null.
     * @param requestRedirectUri
     * @returns Redirect URL
     *
     */
    StandardInteractionClient.prototype.getRedirectUri = function (requestRedirectUri) {
        this.logger.verbose("getRedirectUri called");
        var redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();
        return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri());
    };
    return StandardInteractionClient;
}(BaseInteractionClient));

export { StandardInteractionClient };
//# sourceMappingURL=StandardInteractionClient.js.map
